[{"path":"https://core-bioinformatics.github.io/ClustAssess/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2020 Arash Shahsavari Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/articles/ClustAssess.html","id":"proportion-of-ambiguously-clustered-pairs","dir":"Articles","previous_headings":"","what":"Proportion of ambiguously clustered pairs","title":"Evaluating single-cell clustering with ClustAssess","text":"proportion ambiguously clustered pairs (PAC) uses consensus clustering infer optimal number clusters data, observing variably pairs elements cluster together. lower PAC, stable clustering. PAC originally presented https://doi.org/10.1038/srep06207.","code":"# retrieve scaled data for PAC calculation pbmc.data <- GetAssayData(pbmc_small, assay = \"RNA\", layer = \"scale.data\")  # perform consensus clustering cc.res <- consensus_cluster(t(pbmc.data),     k_max = 30,     n_reps = 100,     p_sample = 0.8,     p_feature = 0.8,     verbose = TRUE ) #> Calculating consensus clustering  # assess the PAC convergence for a few values of k - each curve should # have converged to some value k.plot <- c(4, 6, 8, 10) pac_convergence(cc.res, k.plot) # visualize the final PAC across k - there seems to be a local maximum at k=7, # indicating that 7 clusters leads to a less stable clustering of the data than # nearby values of k pac_landscape(cc.res)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/articles/ClustAssess.html","id":"element-centric-clustering-comparison","dir":"Articles","previous_headings":"","what":"Element-centric clustering comparison","title":"Evaluating single-cell clustering with ClustAssess","text":"compare similarity clustering results methods (case, Louvain community detection k-means) using Element-Centric Similarity (ECS), quantifies clustering similarity per cell. Higher ECS indicates observation clustered similarly across methods. ECS introduced https://doi.org/10.1038/s41598-019-44892-y.","code":"# first, cluster with Louvain algorithm pbmc_small <- FindClusters(pbmc_small, resolution = 0.8, verbose = FALSE) DimPlot(pbmc_small, group.by = \"seurat_clusters\") # also cluster with PCA+k-means pbmc_pca <- Embeddings(pbmc_small, \"pca\") pbmc_small@meta.data$kmeans_clusters <- kmeans(pbmc_pca,     centers = 3,     nstart = 10,     iter.max = 1e3 )$cluster DimPlot(pbmc_small, group.by = \"kmeans_clusters\") # where are the clustering results more similar? pbmc_small@meta.data$ecs <- element_sim_elscore(     pbmc_small@meta.data$seurat_clusters,     pbmc_small@meta.data$kmeans_clusters ) suppressMessages(FeaturePlot(pbmc_small, \"ecs\") + scale_colour_viridis_c()) mean(pbmc_small@meta.data$ecs) #> [1] 0.6632927"},{"path":"https://core-bioinformatics.github.io/ClustAssess/articles/ClustAssess.html","id":"jaccard-similarity-of-cluster-markers","dir":"Articles","previous_headings":"","what":"Jaccard similarity of cluster markers","title":"Evaluating single-cell clustering with ClustAssess","text":"common step computational single-cell RNA-seq analyses, discriminative marker genes identified cluster. markers used infer cell type respective cluster. , compare markers obtained clustering method ask: similarly cell interpreted across clustering methods? compare markers per cell using Jaccard similarity (defined size intersect divided size overlap) marker gene lists. higher JSI, similar marker genes cell.","code":"# first, we calculate the markers on the Louvain clustering Idents(pbmc_small) <- pbmc_small@meta.data$seurat_clusters louvain.markers <- FindAllMarkers(pbmc_small,     logfc.threshold = 1,     min.pct = 0.0,     test.use = \"roc\",     verbose = FALSE )  # then we get the markers on the k-means clustering Idents(pbmc_small) <- pbmc_small@meta.data$kmeans_clusters kmeans.markers <- FindAllMarkers(pbmc_small,     logfc.threshold = 1,     min.pct = 0.0,     test.use = \"roc\",     verbose = FALSE )  # next, compare the top 10 markers per cell pbmc_small@meta.data$marker.gene.jsi <- marker_overlap(louvain.markers,     kmeans.markers,     pbmc_small@meta.data$seurat_clusters,     pbmc_small@meta.data$kmeans_clusters,     n = 10,     rank_by = \"power\" )  # which cells have the same markers, regardless of clustering? suppressMessages(FeaturePlot(pbmc_small, \"marker.gene.jsi\") + scale_colour_viridis_c()) mean(pbmc_small@meta.data$marker.gene.jsi) #> [1] 0.5738636"},{"path":"https://core-bioinformatics.github.io/ClustAssess/articles/ClustAssess.html","id":"element-wise-consistency","dir":"Articles","previous_headings":"","what":"Element-wise consistency","title":"Evaluating single-cell clustering with ClustAssess","text":"consistently cells clustered k-means? rerun k-means clustering 20 times investigate.","code":"clustering.list <- list() n.reps <- 20 for (i in 1:n.reps) {     # we set nstart=1 and a fairly high iter.max - this should mean that     # the algorithm converges, and that the variability in final clusterings     # depends mainly on the random initial cluster assignments     km.res <- kmeans(pbmc_pca, centers = 3, nstart = 1, iter.max = 1e3)$cluster     clustering.list[[i]] <- km.res }  # now, we calculate the element-wise consistency (aka frustration), which # performs pair-wise comparisons between all 20 clusterings; the # consistency is the average per-cell ECS across all comparisons. The higher # the consistency, the more consistently is that cell clustered across # random seeds. pbmc_small@meta.data$consistency <- element_consistency(clustering.list)  # which cells are clustered more consistently? suppressMessages(FeaturePlot(pbmc_small, \"consistency\") + scale_colour_viridis_c()) mean(pbmc_small@meta.data$consistency) #> [1] 0.6712922"},{"path":"https://core-bioinformatics.github.io/ClustAssess/articles/ClustAssess.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info","title":"Evaluating single-cell clustering with ClustAssess","text":"","code":"sessionInfo() #> R version 4.4.0 (2024-04-24) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 22.04.4 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: Europe/Bucharest #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] ggplot2_3.5.1.9000 ClustAssess_1.0.0  Seurat_5.2.0       SeuratObject_5.0.2 #> [5] sp_2.1-4           #>  #> loaded via a namespace (and not attached): #>   [1] RColorBrewer_1.1-3     jsonlite_1.8.9         magrittr_2.0.3         #>   [4] spatstat.utils_3.1-2   farver_2.1.2           rmarkdown_2.29         #>   [7] fs_1.6.5               ragg_1.3.3             vctrs_0.6.5            #>  [10] ROCR_1.0-11            spatstat.explore_3.3-4 htmltools_0.5.8.1      #>  [13] progress_1.2.3         sass_0.4.9             sctransform_0.4.1      #>  [16] parallelly_1.41.0      KernSmooth_2.23-26     bslib_0.8.0            #>  [19] htmlwidgets_1.6.4      desc_1.4.3             ica_1.0-3              #>  [22] plyr_1.8.9             plotly_4.10.4          zoo_1.8-12             #>  [25] cachem_1.1.0           igraph_2.1.4           mime_0.12              #>  [28] lifecycle_1.0.4        iterators_1.0.14       pkgconfig_2.0.3        #>  [31] Matrix_1.7-2           R6_2.5.1               fastmap_1.2.0          #>  [34] fitdistrplus_1.2-2     future_1.34.0          shiny_1.10.0           #>  [37] digest_0.6.37          colorspace_2.1-1       patchwork_1.3.0        #>  [40] tensor_1.5             RSpectra_0.16-2        irlba_2.3.5.1          #>  [43] textshaping_1.0.0      labeling_0.4.3         progressr_0.15.1       #>  [46] spatstat.sparse_3.1-0  httr_1.4.7             polyclip_1.10-7        #>  [49] abind_1.4-8            compiler_4.4.0         withr_3.0.2            #>  [52] fastDummies_1.7.5      MASS_7.3-64            tools_4.4.0            #>  [55] lmtest_0.9-40          httpuv_1.6.15          future.apply_1.11.3    #>  [58] goftest_1.2-3          glue_1.8.0             nlme_3.1-166           #>  [61] promises_1.3.2         grid_4.4.0             Rtsne_0.17             #>  [64] cluster_2.1.8          reshape2_1.4.4         generics_0.1.3         #>  [67] gtable_0.3.6           spatstat.data_3.1-4    tidyr_1.3.1            #>  [70] hms_1.1.3              data.table_1.16.4      spatstat.geom_3.3-5    #>  [73] RcppAnnoy_0.0.22       ggrepel_0.9.6          RANN_2.6.2             #>  [76] foreach_1.5.2          pillar_1.10.1          stringr_1.5.1          #>  [79] spam_2.11-1            RcppHNSW_0.6.0         later_1.4.1            #>  [82] splines_4.4.0          dplyr_1.1.4            lattice_0.22-6         #>  [85] survival_3.8-3         deldir_2.0-4           tidyselect_1.2.1       #>  [88] miniUI_0.1.1.1         pbapply_1.7-2          knitr_1.49             #>  [91] gridExtra_2.3          scattermore_1.2        xfun_0.50              #>  [94] matrixStats_1.5.0      stringi_1.8.4          lazyeval_0.2.2         #>  [97] yaml_2.3.10            evaluate_1.0.3         codetools_0.2-20       #> [100] tibble_3.2.1           cli_3.6.3              uwot_0.2.2             #> [103] xtable_1.8-4           reticulate_1.40.0      systemfonts_1.2.1      #> [106] munsell_0.5.1          jquerylib_0.1.4        Rcpp_1.0.14            #> [109] globals_0.16.3         spatstat.random_3.3-2  png_0.1-8              #> [112] fastcluster_1.2.6      spatstat.univar_3.1-1  parallel_4.4.0         #> [115] pkgdown_2.1.1          prettyunits_1.2.0      dotCall64_1.2          #> [118] listenv_0.9.1          viridisLite_0.4.2      scales_1.3.0           #> [121] ggridges_0.5.6         purrr_1.0.2            crayon_1.5.3           #> [124] rlang_1.1.5            cowplot_1.1.3"},{"path":"https://core-bioinformatics.github.io/ClustAssess/articles/comparing-soft-and-hierarchical.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info","title":"Comparing soft and hierarchical clusterings with element-centric similarity","text":"","code":"sessionInfo() #> R version 4.4.0 (2024-04-24) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 22.04.4 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: Europe/Bucharest #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] ggplot2_3.5.1.9000 ClustAssess_1.0.0  dendextend_1.19.0  dbscan_1.2-0       #> [5] e1071_1.7-16       #>  #> loaded via a namespace (and not attached): #>  [1] viridis_0.6.5     sass_0.4.9        generics_0.1.3    class_7.3-23      #>  [5] lattice_0.22-6    digest_0.6.37     magrittr_2.0.3    evaluate_1.0.3    #>  [9] grid_4.4.0        iterators_1.0.14  fastmap_1.2.0     foreach_1.5.2     #> [13] jsonlite_1.8.9    Matrix_1.7-2      gridExtra_2.3     viridisLite_0.4.2 #> [17] scales_1.3.0      codetools_0.2-20  textshaping_1.0.0 jquerylib_0.1.4   #> [21] cli_3.6.3         rlang_1.1.5       munsell_0.5.1     withr_3.0.2       #> [25] cachem_1.1.0      yaml_2.3.10       tools_4.4.0       dplyr_1.1.4       #> [29] colorspace_2.1-1  vctrs_0.6.5       R6_2.5.1          proxy_0.4-27      #> [33] lifecycle_1.0.4   fs_1.6.5          htmlwidgets_1.6.4 ragg_1.3.3        #> [37] pkgconfig_2.0.3   desc_1.4.3        pkgdown_2.1.1     pillar_1.10.1     #> [41] bslib_0.8.0       gtable_0.3.6      glue_1.8.0        Rcpp_1.0.14       #> [45] systemfonts_1.2.1 xfun_0.50         tibble_3.2.1      tidyselect_1.2.1  #> [49] knitr_1.49        farver_2.1.2      igraph_2.1.4      htmltools_0.5.8.1 #> [53] rmarkdown_2.29    labeling_0.4.3    compiler_4.4.0"},{"path":"https://core-bioinformatics.github.io/ClustAssess/articles/stability-dim-reduction-flexibility.html","id":"clustassess-using-pca","dir":"Articles","previous_headings":"","what":"ClustAssess using PCA","title":"Flexibility of the dimensionality reduction assessment","text":"PCA example, use PBMC 3k dataset SeuratData package. preprocessing dataset identical one performed stability pipeline vignette. notice seurat_annotations column missing values. simplicity, replace “NA”. Select features used stability assessment. Assess stability dimensionality reduction PCA used dimensionality reduction. Plot distribution celltypes UMAP embedding obtained top 1000 Abundant genes.","code":"options(timeout=3600) InstallData(\"pbmc3k\") ## Warning: The following packages are already installed and will not be ## reinstalled: pbmc3k data(\"pbmc3k\") pbmc3k <- UpdateSeuratObject(pbmc3k) ## Validating object structure ## Updating object slots ## Ensuring keys are in the proper structure ## Warning: Assay RNA changing from Assay to Assay ## Ensuring keys are in the proper structure ## Ensuring feature names don't have underscores or pipes ## Updating slots in RNA ## Validating object structure for Assay 'RNA' ## Object representation is consistent with the most current Seurat version pbmc3k <- PercentageFeatureSet(pbmc3k, pattern = \"^MT-\", col.name = \"percent.mito\") pbmc3k <- PercentageFeatureSet(pbmc3k, pattern = \"^RP[SL][[:digit:]]\", col.name = \"percent.rp\") # remove MT and RP genes all.index <- seq_len(nrow(pbmc3k)) MT.index <- grep(pattern = \"^MT-\", x = rownames(pbmc3k), value = FALSE) RP.index <- grep(pattern = \"^RP[SL][[:digit:]]\", x = rownames(pbmc3k), value = FALSE) pbmc3k <- pbmc3k[!((all.index %in% MT.index) | (all.index %in% RP.index)), ] pbmc3k <- subset(pbmc3k, nFeature_RNA < 2000 & nCount_RNA < 2500 & percent.mito < 7 & percent.rp > 7) pbmc3k <- NormalizeData(pbmc3k, verbose = FALSE) pbmc3k <- FindVariableFeatures(pbmc3k, selection.method = \"vst\", nfeatures = 3000, verbose = FALSE)  features <- dimnames(pbmc3k@assays$RNA)[[1]] var_features <- pbmc3k@assays[[\"RNA\"]]@var.features n_abundant <- 3000 most_abundant_genes <- rownames(pbmc3k@assays$RNA)[order(Matrix::rowSums(pbmc3k@assays$RNA),     decreasing = TRUE )]  pbmc3k <- ScaleData(pbmc3k, features = features, verbose = FALSE) mask <- is.na(pbmc3k$seurat_annotations) pbmc3k$seurat_annotations <- as.character(pbmc3k$seurat_annotations) pbmc3k$seurat_annotations[mask] <- \"NA\" features <- dimnames(pbmc3k@assays$RNA)[[1]] var_features <- pbmc3k@assays[[\"RNA\"]]@var.features n_abundant <- 3000 most_abundant_genes <- rownames(pbmc3k@assays$RNA)[order(Matrix::rowSums(pbmc3k@assays$RNA),     decreasing = TRUE )]  steps <- seq(from = 500, to = 3000, by = 500) ma_hv_genes_intersection_sets <- sapply(steps, function(x) intersect(most_abundant_genes[1:x], var_features[1:x])) ma_hv_genes_intersection <- Reduce(union, ma_hv_genes_intersection_sets) ma_hv_steps <- sapply(ma_hv_genes_intersection_sets, length) matrix_processing_function <- function(dt_mtx, actual_npcs = 30) {     actual_npcs <- min(actual_npcs, ncol(dt_mtx) %/% 2)      RhpcBLASctl::blas_set_num_threads(foreach::getDoParWorkers())     embedding <- stats::prcomp(x = dt_mtx, rank. = actual_npcs)$x      RhpcBLASctl::blas_set_num_threads(1)     rownames(embedding) <- rownames(dt_mtx)     colnames(embedding) <- paste0(\"PC_\", seq_len(actual_npcs))      return(embedding) }  pca_feature_stability <- assess_feature_stability(     data_matrix = pbmc3k@assays[[\"RNA\"]]@scale.data,     feature_set = most_abundant_genes,     resolution = seq(from = 0.1, to = 1, by = 0.1),     steps = steps,     n_repetitions = n_repetitions,     feature_type = \"MA\",     graph_reduction_type = \"PCA\",     matrix_processing = matrix_processing_function,     umap_arguments = list(         min_dist = 0.3,         n_neighbors = 30,         metric = \"cosine\"     ),     ecs_thresh = 1,     clustering_algorithm = 1 ) ## Warning: executing %dopar% sequentially: no parallel backend registered umap_df <- data.frame(pca_feature_stability$embedding_list$MA$\"1000\") umap_df$celltypes <- pbmc3k$seurat_annotations ggplot(umap_df, aes(x = UMAP_1, y = UMAP_2, color = celltypes)) +     geom_point() +     theme_classic()"},{"path":"https://core-bioinformatics.github.io/ClustAssess/articles/stability-dim-reduction-flexibility.html","id":"clustassess-using-harmony","dir":"Articles","previous_headings":"","what":"ClustAssess using Harmony","title":"Flexibility of the dimensionality reduction assessment","text":"can also modify function adding addition post-processing step PCA. example, use Harmony correction remove “batch effect” created celltypes. Note: example meant exemplify use Harmony correction ClusAssess pipeline. batch correction actually needed PBMC 3k dataset. Plot distribution celltypes UMAP embedding obtained top 1000 Abundant genes.","code":"matrix_processing_function <- function(dt_mtx, actual_npcs = 30) {     actual_npcs <- min(actual_npcs, ncol(dt_mtx) %/% 2)      RhpcBLASctl::blas_set_num_threads(foreach::getDoParWorkers())     embedding <- stats::prcomp(x = dt_mtx, rank. = actual_npcs)$x      RhpcBLASctl::blas_set_num_threads(1)     rownames(embedding) <- rownames(dt_mtx)     colnames(embedding) <- paste0(\"PC_\", seq_len(actual_npcs))      embedding <- RunHarmony(embedding, pbmc3k$seurat_annotations, verbose = FALSE)      return(embedding) }  pca_harmony_feature_stability <- assess_feature_stability(     data_matrix = pbmc3k@assays[[\"RNA\"]]@scale.data,     feature_set = most_abundant_genes,     resolution = seq(from = 0.1, to = 1, by = 0.1),     steps = steps,     n_repetitions = n_repetitions,     feature_type = \"MA\",     graph_reduction_type = \"PCA\",     matrix_processing = matrix_processing_function,     umap_arguments = list(         min_dist = 0.3,         n_neighbors = 30,         metric = \"cosine\"     ),     ecs_thresh = 1,     clustering_algorithm = 1,     verbose = TRUE ) umap_df <- data.frame(pca_harmony_feature_stability$embedding_list$MA$\"1000\") umap_df$celltypes <- pbmc3k$seurat_annotations ggplot(umap_df, aes(x = UMAP_1, y = UMAP_2, color = celltypes)) +     geom_point() +     theme_classic()"},{"path":"https://core-bioinformatics.github.io/ClustAssess/articles/stability-dim-reduction-flexibility.html","id":"clustassess-in-the-scatac-seq-data","dir":"Articles","previous_headings":"","what":"ClustAssess in the scATAC-seq data","title":"Flexibility of the dimensionality reduction assessment","text":"example showcase flexibility assess_feature_stability function using ATAC-seq data. example, use multiome PBMC dataset SeuratData package. presented (Signac)(https://stuartlab.org/signac/articles/pbmc_vignette) package, ATAC-seq data usually processed using TF-IDF normalization followed calculation singular values. two steps also known LSI (Latent Semantic Indexing). Identify highly variable peaks. speedup assessment, set parallel backend 6 cores. Assess stability dimensionality reduction varying number highly variable peaks. Plot distribution celltypes UMAP embedding obtained top 1000 Highly Variable peaks.","code":"library(Signac) InstallData(\"pbmcMultiome\") ## Warning: The following packages are already installed and will not be ## reinstalled: pbmcMultiome data(\"pbmc.atac\") pbmc.atac <- RunTFIDF(pbmc.atac) ## Performing TF-IDF normalization ## Warning in RunTFIDF.default(object = GetAssayData(object = object, layer = ## \"counts\"), : Some features contain 0 total counts pbmc.atac <- FindTopFeatures(pbmc.atac, min.cutoff = \"q5\") var_peaks <- pbmc.atac@assays$ATAC@var.features[seq_len(3000)] RhpcBLASctl::blas_set_num_threads(1) ncores <- 1 if (ncores > 1) {     my_cluster <- parallel::makeCluster(         ncores,         type = \"PSOCK\"     )      doParallel::registerDoParallel(cl = my_cluster) } matrix_processing_function <- function(dt_mtx, actual_n_singular_values = 50) {     actual_n_singular_values <- min(actual_n_singular_values, ncol(dt_mtx) %/% 2)      RhpcBLASctl::blas_set_num_threads(foreach::getDoParWorkers())     embedding <- RunSVD(Matrix::t(dt_mtx), n = actual_n_singular_values, verbose = FALSE)@cell.embeddings     # remove the first component, as it does contain noise - see the Signac vignette     embedding <- embedding[, 2:actual_n_singular_values]      RhpcBLASctl::blas_set_num_threads(1)     rownames(embedding) <- rownames(dt_mtx)     colnames(embedding) <- paste0(\"LSI_\", seq_len(actual_n_singular_values - 1))      return(embedding) }  lsi_atac_feature_stability <- assess_feature_stability(     data_matrix = pbmc.atac@assays[[\"ATAC\"]]@data,     feature_set = var_peaks,     resolution = seq(from = 0.1, to = 1, by = 0.1),     steps = steps,     n_repetitions = n_repetitions,     feature_type = \"HV_peaks\",     graph_reduction_type = \"PCA\",     matrix_processing = matrix_processing_function,     umap_arguments = list(         min_dist = 0.3,         n_neighbors = 30,         metric = \"cosine\"     ),     ecs_thresh = 1,     clustering_algorithm = 1,     verbose = TRUE ) ## Warning: No assay specified, setting assay as RNA by default. ## No assay specified, setting assay as RNA by default. ## No assay specified, setting assay as RNA by default. ## No assay specified, setting assay as RNA by default. ## No assay specified, setting assay as RNA by default. ## No assay specified, setting assay as RNA by default. foreach::registerDoSEQ() umap_df <- data.frame(lsi_atac_feature_stability$embedding_list$HV_peaks$\"1000\") umap_df$celltypes <- pbmc.atac$seurat_annotations ggplot(umap_df, aes(x = UMAP_1, y = UMAP_2, color = celltypes)) +     geom_point() +     theme_classic()"},{"path":"https://core-bioinformatics.github.io/ClustAssess/articles/stability-dim-reduction-flexibility.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info","title":"Flexibility of the dimensionality reduction assessment","text":"","code":"sessionInfo() ## R version 4.4.0 (2024-04-24) ## Platform: x86_64-pc-linux-gnu ## Running under: Ubuntu 22.04.4 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 ##  ## locale: ##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        ##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    ##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           ## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    ##  ## time zone: Europe/Bucharest ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] stats4    stats     graphics  grDevices utils     datasets  methods   ## [8] base      ##  ## other attached packages: ##  [1] Signac_1.14.0                 data.table_1.16.4             ##  [3] ggplot2_3.5.1.9000            ClustAssess_1.0.0             ##  [5] Seurat_5.2.0                  SeuratObject_5.0.2            ##  [7] sp_2.1-4                      Rsamtools_2.22.0              ##  [9] Biostrings_2.74.1             XVector_0.46.0                ## [11] GenomicRanges_1.58.0          GenomeInfoDb_1.42.1           ## [13] IRanges_2.40.1                S4Vectors_0.44.0              ## [15] BiocGenerics_0.52.0           harmony_1.2.3                 ## [17] Rcpp_1.0.14                   pbmcMultiome.SeuratData_0.1.4 ## [19] pbmc3k.SeuratData_3.1.4       SeuratData_0.2.2.9001         ##  ## loaded via a namespace (and not attached): ##   [1] RColorBrewer_1.1-3      jsonlite_1.8.9          magrittr_2.0.3          ##   [4] spatstat.utils_3.1-2    farver_2.1.2            rmarkdown_2.29          ##   [7] zlibbioc_1.52.0         fs_1.6.5                ragg_1.3.3              ##  [10] vctrs_0.6.5             ROCR_1.0-11             spatstat.explore_3.3-4  ##  [13] RcppRoll_0.3.1          progress_1.2.3          htmltools_0.5.8.1       ##  [16] sass_0.4.9              sctransform_0.4.1       parallelly_1.41.0       ##  [19] KernSmooth_2.23-26      bslib_0.8.0             htmlwidgets_1.6.4       ##  [22] desc_1.4.3              ica_1.0-3               plyr_1.8.9              ##  [25] plotly_4.10.4           zoo_1.8-12              cachem_1.1.0            ##  [28] igraph_2.1.4            iterators_1.0.14        mime_0.12               ##  [31] lifecycle_1.0.4         pkgconfig_2.0.3         Matrix_1.7-2            ##  [34] R6_2.5.1                fastmap_1.2.0           GenomeInfoDbData_1.2.13 ##  [37] fitdistrplus_1.2-2      future_1.34.0           shiny_1.10.0            ##  [40] digest_0.6.37           colorspace_2.1-1        patchwork_1.3.0         ##  [43] tensor_1.5              RSpectra_0.16-2         irlba_2.3.5.1           ##  [46] textshaping_1.0.0       labeling_0.4.3          progressr_0.15.1        ##  [49] spatstat.sparse_3.1-0   httr_1.4.7              polyclip_1.10-7         ##  [52] abind_1.4-8             compiler_4.4.0          withr_3.0.2             ##  [55] BiocParallel_1.40.0     fastDummies_1.7.5       MASS_7.3-64             ##  [58] rappdirs_0.3.3          tools_4.4.0             lmtest_0.9-40           ##  [61] httpuv_1.6.15           future.apply_1.11.3     goftest_1.2-3           ##  [64] glue_1.8.0              nlme_3.1-166            promises_1.3.2          ##  [67] grid_4.4.0              Rtsne_0.17              cluster_2.1.8           ##  [70] reshape2_1.4.4          generics_0.1.3          gtable_0.3.6            ##  [73] spatstat.data_3.1-4     tidyr_1.3.1             hms_1.1.3               ##  [76] spatstat.geom_3.3-5     RcppAnnoy_0.0.22        foreach_1.5.2           ##  [79] ggrepel_0.9.6           RANN_2.6.2              pillar_1.10.1           ##  [82] stringr_1.5.1           spam_2.11-1             RcppHNSW_0.6.0          ##  [85] later_1.4.1             splines_4.4.0           dplyr_1.1.4             ##  [88] lattice_0.22-6          survival_3.8-3          deldir_2.0-4            ##  [91] tidyselect_1.2.1        miniUI_0.1.1.1          pbapply_1.7-2           ##  [94] knitr_1.49              gridExtra_2.3           scattermore_1.2         ##  [97] RhpcBLASctl_0.23-42     xfun_0.50               SharedObject_1.20.0     ## [100] matrixStats_1.5.0       UCSC.utils_1.2.0        stringi_1.8.4           ## [103] lazyeval_0.2.2          yaml_2.3.10             evaluate_1.0.3          ## [106] codetools_0.2-20        tibble_3.2.1            cli_3.6.3               ## [109] uwot_0.2.2              xtable_1.8-4            reticulate_1.40.0       ## [112] systemfonts_1.2.1       munsell_0.5.1           jquerylib_0.1.4         ## [115] globals_0.16.3          spatstat.random_3.3-2   png_0.1-8               ## [118] spatstat.univar_3.1-1   parallel_4.4.0          pkgdown_2.1.1           ## [121] prettyunits_1.2.0       dotCall64_1.2           bitops_1.0-9            ## [124] listenv_0.9.1           viridisLite_0.4.2       scales_1.3.0            ## [127] ggridges_0.5.6          purrr_1.0.2             crayon_1.5.3            ## [130] rlang_1.1.5             fastmatch_1.1-6         cowplot_1.1.3"},{"path":"https://core-bioinformatics.github.io/ClustAssess/articles/stability-pipeline-description.html","id":"calculating-ecs-ecc","dir":"Articles","previous_headings":"","what":"Calculating ECS, ECC","title":"Stability-based parameter assessment","text":"following test functionality ClustAssess package terms calculating ECS ECC.","code":"mb1 <- c(1, 1, 1, 2, 2, 2, 3, 3) mb2 <- c(1, 2, 1, 2, 2, 2, 3, 3)  # calculate the ECS score for each observation print(element_sim_elscore(mb1, mb2)) #> [1] 0.6666667 0.2500000 0.6666667 0.7500000 0.7500000 0.7500000 1.0000000 #> [8] 1.0000000 # calculate the average ECS print(mean(element_sim_elscore(mb1, mb2))) #> [1] 0.7291667 print(element_sim(mb1, mb2)) #> [1] 0.7291667 # create a list of 10 random partitions list_mbs <- lapply(1:10, function(i) {     sample.int(4, 5, replace = TRUE) }) print(list_mbs) #> [[1]] #> [1] 3 3 3 3 4 #>  #> [[2]] #> [1] 3 4 3 2 2 #>  #> [[3]] #> [1] 4 4 4 4 4 #>  #> [[4]] #> [1] 1 1 3 2 3 #>  #> [[5]] #> [1] 2 2 4 3 4 #>  #> [[6]] #> [1] 1 4 2 3 2 #>  #> [[7]] #> [1] 2 3 4 1 2 #>  #> [[8]] #> [1] 4 1 4 2 4 #>  #> [[9]] #> [1] 3 2 2 2 4 #>  #> [[10]] #> [1] 1 2 4 3 1 element_consistency(list_mbs) #> [1] 0.4918519 0.5451852 0.4925926 0.5740741 0.5385185"},{"path":[]},{"path":"https://core-bioinformatics.github.io/ClustAssess/articles/stability-pipeline-description.html","id":"reading-the-data","dir":"Articles","previous_headings":"Stability pipeline","what":"Reading the data","title":"Stability-based parameter assessment","text":"vignette illustrate data-driven pipeline assessment optimal clustering parameters single-cell RNA-seq dataset. Popular pipelines single-cell clustering (including Seurat, SCANPY, Monocle v3) consist sequence steps, including normalization, dimensionality reduction, nearest-neighbor graph construction, community detection graph. obtained communities clusters, can used downstream analysis looking marker genes, trajectories, . ClustAssess offers set tools assess stability parameters clustering pipeline, steps dimensionality reduction, nearest-neighbor graph construction, community detection. illustrate tools, use PBMC 3k dataset provided SeuratData package. input provided 13714x 2700 expression level matrix containing raw quantification (csv format). analysis based Seurat pipeline (Hao et al 2021, Integrated analysis multimodal single-cell data); creating object recording mitochondrial ribosomal gene percentages, genes excluded downstream analysis.","code":"InstallData(\"pbmc3k\") #> Warning: The following packages are already installed and will not be #> reinstalled: pbmc3k data(\"pbmc3k\") pbmc3k <- UpdateSeuratObject(pbmc3k) #> Validating object structure #> Updating object slots #> Ensuring keys are in the proper structure #> Warning: Assay RNA changing from Assay to Assay #> Ensuring keys are in the proper structure #> Ensuring feature names don't have underscores or pipes #> Updating slots in RNA #> Validating object structure for Assay 'RNA' #> Object representation is consistent with the most current Seurat version pbmc3k #> An object of class Seurat  #> 13714 features across 2700 samples within 1 assay  #> Active assay: RNA (13714 features, 0 variable features) #>  2 layers present: counts, data pbmc3k <- PercentageFeatureSet(pbmc3k, pattern = \"^MT-\", col.name = \"percent.mito\") pbmc3k <- PercentageFeatureSet(pbmc3k, pattern = \"^RP[SL][[:digit:]]\", col.name = \"percent.rp\")"},{"path":"https://core-bioinformatics.github.io/ClustAssess/articles/stability-pipeline-description.html","id":"quality-checks","dir":"Articles","previous_headings":"Stability pipeline","what":"Quality checks","title":"Stability-based parameter assessment","text":"remove mithocondrial ribosomal genes. plot violin plots visualise distribution number features, number counts, percentage mitochondrial genes, percentage ribosomal genes.  quality control step, filter dataset using following criteria: - number features less 2000 - number counts less 2500 - percentage mitochondrial genes less 7% - percentage ribosomal genes greater 7% plot violin plots see distribution features filtering step.","code":"# remove MT and RP genes all.index <- seq_len(nrow(pbmc3k)) MT.index <- grep(pattern = \"^MT-\", x = rownames(pbmc3k), value = FALSE) RP.index <- grep(pattern = \"^RP[SL][[:digit:]]\", x = rownames(pbmc3k), value = FALSE) pbmc3k <- pbmc3k[!((all.index %in% MT.index) | (all.index %in% RP.index)), ] VlnPlot(pbmc3k, features = c(\"nFeature_RNA\", \"nCount_RNA\", \"percent.mito\", \"percent.rp\"), ncol = 2) pbmc3k <- subset(pbmc3k, nFeature_RNA < 2000 & nCount_RNA < 2500 & percent.mito < 7 & percent.rp > 7) VlnPlot(pbmc3k, features = c(\"nFeature_RNA\", \"nCount_RNA\", \"percent.mito\", \"percent.rp\"), ncol = 2)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/articles/stability-pipeline-description.html","id":"normalization-and-scaling","dir":"Articles","previous_headings":"Stability pipeline","what":"Normalization and scaling","title":"Stability-based parameter assessment","text":"data normalized scaled using Seurat’s NormalizeData ScaleData methods. variable feature set obtained running FindVariableFeatures function package. generate following plots: - distribution predefined Seurat celltype annotations; B – E distributions sequencing depths (B), number features (C), percentages reads incident mitochondrial genes (D) ribosomal genes (E) illustrated using colour gradient.","code":"pbmc3k <- NormalizeData(pbmc3k, verbose = FALSE) pbmc3k <- FindVariableFeatures(pbmc3k, selection.method = \"vst\", nfeatures = 3000, verbose = FALSE)  features <- dimnames(pbmc3k@assays$RNA)[[1]] var_features <- pbmc3k@assays[[\"RNA\"]]@var.features n_abundant <- 3000 most_abundant_genes <- rownames(pbmc3k@assays$RNA)[order(Matrix::rowSums(pbmc3k@assays$RNA),     decreasing = TRUE )]  pbmc3k <- ScaleData(pbmc3k, features = features, verbose = FALSE)  pbmc3k <- RunPCA(pbmc3k,     npcs = 30,     approx = FALSE,     verbose = FALSE,     features = intersect(most_abundant_genes, pbmc3k@assays$RNA@var.features) ) pbmc3k <- RunUMAP(pbmc3k,     reduction = \"pca\",     dims = 1:30,     n.neighbors = 30,     min.dist = 0.3,     metric = \"cosine\",     verbose = FALSE ) raw_umap <- data.frame(pbmc3k@reductions$umap@cell.embeddings)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/articles/stability-pipeline-description.html","id":"effect-of-the-random-seed","dir":"Articles","previous_headings":"Stability pipeline","what":"Effect of the random seed","title":"Stability-based parameter assessment","text":"illustrate necessity obtaining reproducible robust clustering outputs, perform clustering step several times changing random seed. assess stability clustering calculating consistency 10 clustering outputs. similarity distinct partitions can assessed accessing ecs_matrix field. difference clusters can visualised using ECC distribution. Also, comparing output clustering using second fourth seed, notice cells top-left island change identity fifth seventh cluster.","code":"pbmc3k <- FindNeighbors(pbmc3k) #> Computing nearest neighbor graph #> Computing SNN clustering_list <- lapply(seq(from = 1, by = 100, length.out = 10), function(i) {     pbmc3k <- FindClusters(pbmc3k, algorithm = 3, random.seed = i, verbose = FALSE)     as.integer(pbmc3k$seurat_clusters) }) ecc_value <- merge_partitions(clustering_list, return_ecs_matrix = TRUE) print(fivenum(ecc_value$ecc)) #> [1] 0.5437092 0.9953488 1.0000000 1.0000000 1.0000000 print(ecc_value$ecs_matrix) #>           [,1]      [,2]      [,3] #> [1,] 1.0000000 0.9915337 0.9950592 #> [2,] 0.9915337 1.0000000 0.9866320 #> [3,] 0.9950592 0.9866320 1.0000000 gplots <- list() gplots[[1]] <- ggplot(raw_umap, aes(x = umap_1, y = umap_2, colour = ecc_value$ecc)) +     geom_point() +     theme_classic() +     scale_colour_viridis_c() raw_umap$clustering <- factor(clustering_list[[2]]) gplots[[2]] <- ggplot(raw_umap, aes(x = umap_1, y = umap_2, colour = clustering)) +     geom_point() + theme_classic() raw_umap$clustering <- factor(clustering_list[[4]]) gplots[[3]] <- ggplot(raw_umap, aes(x = umap_1, y = umap_2, colour = clustering)) +     geom_point() + theme_classic()  wrap_plots(gplots)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/articles/stability-pipeline-description.html","id":"applying-clustassess","dir":"Articles","previous_headings":"Stability pipeline","what":"Applying ClustAssess","title":"Stability-based parameter assessment","text":"Note: following sections provide example applying ClustAssess summary assessment methods. values parameters varied critically assessed individual dataset. Also, recommend increasing number repetitions used stability inference, ensure reliable robust conclusions. following analysis performed varying seed multiple times. pipeline can run parallel, initialising backend multiple number cores, task split processess. Setting value 1 result sequential run iterations. encourage usage higher number cores possible, decrease runtime assessment pipeline. Please note number cores chosen carefully, newly created process add memory usage.","code":"n_repetitions <- 10 RhpcBLASctl::blas_set_num_threads(1) ncores <- 1 if (ncores > 1) {     my_cluster <- parallel::makeCluster(         ncores,         type = \"PSOCK\"     )      doParallel::registerDoParallel(cl = my_cluster) }"},{"path":"https://core-bioinformatics.github.io/ClustAssess/articles/stability-pipeline-description.html","id":"dimensionality-reduction","dir":"Articles","previous_headings":"Stability pipeline > Applying ClustAssess","what":"Dimensionality reduction","title":"Stability-based parameter assessment","text":"first parameter evaluate note substantially influence dimensionality reduction (linear non-linear) feature set. Seurat pipeline relies highly variable genes (default) computation Principal Components. top x variable genes abundant genes can selected, x varies according characteristics dataset; frequently used values 500, 1000, 2000, 3000 etc. showcase importance parameter, assess three different sets features: highly variable genes: set can obtained Seurat pipeline using either SCTransform FindVariableFeatures method. Depending method, using default parameters get number 2000 3000 genes. abundant genes: set can obtained sorting genes based expression level. intersection highly variable abundant genes: set obtained intersecting subset abundant genes highly variable feature set. Taking intersection lead smaller number genes compared initial sets. assess_feature_stability function explores stability feature set. input consists normalized expression matrix, summarized using either PCA UMAP. obtained embedding processed using one community detection methods used Seurat package. process iterated across random seeds. method outputs list containing UMAP embedding, cell assignment corresponding frequent partition Element-Centric Consistency (ECC) across communities obtained throughout iterations. higher Element-Centric Consistency, stable clustering. increase robustness stability assessment, also vary resolution parameter directly impacts number clusters. function assess_feature_stability outputs stability different feature sets concatenates results ease cross-comparisons. plot illustrates stability assessment, across 30 runs, different random seeds, three gene sets described . assessed stability set incremental number selected genes. Thus, boxplots arranged groups three (number evaluated feature sets); boxplot specify number elements per subset. user can interogate stability values obtained resolution value, indicated left-side panel, overall stability assessment (determined collecting median ECC-distribution resolution value), can seen right-side panel. PBMC case study, conclusion supported based plot configurations MA 500, 2000, 2500, 3000, HV 500, 1000, 1500, 2500 MA_HV 65, 175, 425 suitable choices Principal Components Analysis, ECC score high low-variance distribution.  Another angle assessing stability centered comparison consecutive steps, feature set, performed using Element-Centric Similarity frequent partitions step. aim evaluating effect increasing number genes final partitions, , indirectly, determining transition signal noise zone. PBMC case study, observe increase similarity consecutive steps MA MA_HV genes, suggesting selecting genes lead robust partitioning.  enhance summarized information presented boxplots, use plot_feature_stability_mb_facet visualize corresponding facet plot displaying frequent partitions feature set step UMAP embedding. plot can reveal additional insights .e. stability gene set might explained part scattered distribution cells across multiple islands. PBMC case study notice similar topology three feature sets.  understand areas instability, provide additional plot display, UMAPs , Element-Centric Consistency score partitions obtained step feature set. case, notice source instability located main island cells. visualizations can help us understand relationship stability topology data.  PBMC case study, based plots presented , conclude feature set highly impact topology data. Judging consistency across multiple runs different random seeds incremental stability, select top 1000 Highly Variable genes.","code":"steps <- seq(from = 500, to = 3000, by = 500) ma_hv_genes_intersection_sets <- sapply(steps, function(x) intersect(most_abundant_genes[seq_len(x)], var_features[seq_len(x)])) ma_hv_genes_intersection <- Reduce(union, ma_hv_genes_intersection_sets) ma_hv_steps <- sapply(ma_hv_genes_intersection_sets, length) pca_feature_stability_object <- mapply(c,     assess_feature_stability(         data_matrix = pbmc3k@assays[[\"RNA\"]]@scale.data,         feature_set = most_abundant_genes,         resolution = seq(from = 0.1, to = 1, by = 0.1),         steps = steps,         n_repetitions = n_repetitions,         feature_type = \"MA\",         graph_reduction_type = \"PCA\",         umap_arguments = list(             min_dist = 0.3,             n_neighbors = 30,             metric = \"cosine\"         ),         ecs_thresh = 1,         clustering_algorithm = 1     ),     assess_feature_stability(         data_matrix = pbmc3k@assays[[\"RNA\"]]@scale.data,         feature_set = var_features,         resolution = seq(from = 0.1, to = 1, by = 0.1),         steps = steps,         n_repetitions = n_repetitions,         feature_type = \"HV\",         graph_reduction_type = \"PCA\",         umap_arguments = list(             min_dist = 0.3,             n_neighbors = 30,             metric = \"cosine\"         ),         ecs_thresh = 1,         clustering_algorithm = 1     ),     assess_feature_stability(         data_matrix = pbmc3k@assays[[\"RNA\"]]@scale.data,         feature_set = ma_hv_genes_intersection,         steps = ma_hv_steps,         resolution = seq(from = 0.1, to = 1, by = 0.1),         n_repetitions = n_repetitions,         feature_type = \"MA_HV\",         graph_reduction_type = \"PCA\",         umap_arguments = list(             min_dist = 0.3,             n_neighbors = 30,             metric = \"cosine\"         ),         ecs_thresh = 1,         clustering_algorithm = 1     ),     SIMPLIFY = FALSE ) wrap_plots(   plot_feature_per_resolution_stability_boxplot(pca_feature_stability_object, resolution = 0.8, text_size = 2.5, boxplot_width = 0.4, dodge_width = 0.7) +     theme(         legend.position = c(1, 0),         legend.justification = c(1, 0)     ),   plot_feature_overall_stability_boxplot(pca_feature_stability_object, text_size = 2.5, boxplot_width = 0.4, dodge_width = 0.7) +     theme(         legend.position = c(1, 0),         legend.justification = c(1, 0)     ) ) #> Warning: A numeric `legend.position` argument in `theme()` was deprecated in ggplot2 #> 3.5.0. #> ℹ Please use the `legend.position.inside` argument of `theme()` instead. #> This warning is displayed once every 8 hours. #> Call `lifecycle::last_lifecycle_warnings()` to see where this warning was #> generated. wrap_plots( plot_feature_per_resolution_stability_incremental(pca_feature_stability_object, dodge_width = 0.6, resolution = 0.8, text_size = 2) +     theme(         legend.position = c(1, 0),         legend.justification = c(1, 0)     ), plot_feature_overall_stability_incremental(pca_feature_stability_object, dodge_width = 0.6, text_size = 2) +     theme(         legend.position = c(1, 0),         legend.justification = c(1, 0)     ) ) plot_feature_stability_mb_facet(     feature_object_list = pca_feature_stability_object,     resolution = 0.8,     text_size = 3,     n_facet_cols = 6 ) plot_feature_stability_ecs_facet(pca_feature_stability_object, resolution = 0.8, n_facet_cols = 6) pbmc3k <- pbmc3k[var_features[seq_len(1000)], ]  pbmc3k <- RunPCA(pbmc3k,     npcs = 30,     approx = FALSE,     features = var_features,     verbose = FALSE ) pbmc3k<- RunUMAP(pbmc3k,     reduction = \"pca\",     dims = 1:30,     n.neighbors = 30,     min.dist = 0.3,     metric = \"cosine\",     verbose = FALSE )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/articles/stability-pipeline-description.html","id":"graph-construction","dir":"Articles","previous_headings":"Stability pipeline > Applying ClustAssess","what":"Graph construction","title":"Stability-based parameter assessment","text":"next step standard single-cell analysis pipeline building graph using nearest neighbour algorithm. following parameters influence final partitioning: base embedding: graph can built either PCA UMAP embedding (using expression matrix isn’t recommended, distances noisier runtime increase) number neighbours graph type: graph can either unweighted (NN case) based weighted Shared-Nearest Neighbours (SNN) graph. latter, weights computed using Jaccard Similarity Index (JSI) neighbourhoods two cells. get_nn_conn_comps method used link number neighbours number connected components (connected component subgraph within exists path every pair nodes). method accepts input PCA UMAP reductions; distribution number connected components obtainable given number neighbours calculated across random seeds. output list containing, number neighbours, array number connected components obtained different seeds. , objects can concatenated facilitate comparisons different configurations reductions. following plot describes covariation number neighbours number connected components obtained using PCA UMAP reductions base graph building. number neighbours increases, number connected components decreases (expected result, increasing number neighbours result better connected graph). Please note number connected components provides lower bound number clusters can obtain downstream community detection algorithms Louvain Leiden. Another comparison may performed PCA UMAP embeddings assess graph connectivity. note , using UMAPs, groups cells separated compared PCAs, quick convergence connected graph (graph exists path every two nodes) obtained. link number connected components functional interpretation results former interpreted minimum number clusters obtained given number neighbours e.g. UMAP case, obtain 5 communities clustering step, require least 5 nearest neighbours.  get_nn_importance method used assessing impact number nearest neighbours, graph type (NN SNN) base embedding (PCA UMAP) determining final number clusters. input either normalized expression matrix PCA embedding, range number neighbours reduction type used building graph. graph type provided, method check cases .e. NN SNN. output comprises list configurations (reduction type, graph type). configuration contain list unique partitions obtained multiple runs (iterations) selected value nearest neighbours. input resulting object plot_n_neigh_k_correspondence, generate following plot; summarizes relationship number nearest neighbours k, number clusters. # neighbours vs # connected components correspondence plot, note similar descending trend number clusters number nearest neighbours increases. plot also illustrates difference two graph types: SNN tighter distribution k (multiple iterations) compared NN. initial object contains graphs based UMAP PCA embedding, plot showcase impact choice, well. PBMC dataset, notice UMAP-based graph partitioned greater number clusters compared PCA case.  stability parameters can also evaluated using Element-Centric Consistency applied partition list obtained multiple runs. following summary plot underlines evolution consistency number neighbours increases; PCA graphs yields stable results even smaller number nearest neighbours, whereas UMAP exhibits stability improvement number neighbours increases. number nearest neighbors, SNN stable NN.","code":"nn_conn_comps_object <- get_nn_conn_comps(     embedding = pbmc3k@reductions$pca@cell.embeddings,     n_neigh_sequence = c(c(1, 2, 3, 4), seq(from = 5, to = 30, by = 5)),     n_repetitions = n_repetitions,     include_umap = TRUE,     umap_arguments = list(         min_dist = 0.3,         n_neighbors = 30,         metric = \"cosine\"     ) ) plot_connected_comps_evolution(nn_conn_comps_object) #> Warning in ggplot2::scale_y_continuous(breaks = chosen_breaks, trans = #> \"log10\"): log-10 transformation introduced infinite values. nn_importance_object <- mapply(c,     assess_nn_stability(         embedding = pbmc3k@reductions$pca@cell.embeddings,         n_neigh_sequence = seq(from = 5, to = 30, by = 5),         n_repetitions = n_repetitions,         graph_reduction_type = \"PCA\",         ecs_thresh = 1,         clustering_algorithm = 1     ),     assess_nn_stability(         embedding = pbmc3k@reductions$pca@cell.embeddings,         n_neigh_sequence = seq(from = 5, to = 30, by = 5),         n_repetitions = n_repetitions,         graph_reduction_type = \"UMAP\",         ecs_thresh = 1,         umap_arguments = list(             min_dist = 0.3,             n_neighbors = 30,             metric = \"cosine\"         ),         clustering_algorithm = 1     ),     SIMPLIFY = FALSE ) plot_n_neigh_k_correspondence(nn_importance_object) #> Warning in ggplot2::scale_y_continuous(breaks = chosen_breaks, trans = #> \"log10\"): log-10 transformation introduced infinite values. plot_n_neigh_ecs(nn_importance_object)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/articles/stability-pipeline-description.html","id":"graph-clustering","dir":"Articles","previous_headings":"Stability pipeline > Applying ClustAssess","what":"Graph clustering","title":"Stability-based parameter assessment","text":"final step standard single-cell analysis pipeline applying graph-based clustering method. Choosing community detection algorithm significant impact partitioning results. Using get_clustering_difference assess stability reproducibility results obtained using various graph clustering methods available Seurat package: Louvain, Louvain refined, SLM Leiden. previously suggested, resolution parameter affects number clusters obtained. get_resolution_importance evaluates effect range values resolution parameter stability output. Besides resolution, user can input multiple values following parameters: number neighbours, graph type clustering method. function return list associated parameter value combination. resolution value, list contain multiple sublists partitions corresponding specific number clusters. stability methods evaluated using Element-Centric Consistency (ECC), applied partition list obtained multiple runs. following summary plot underlines variation consistency resolution parameter increases. boxplot, display number clusters corresponding frequent partition clustering method specific resolution parameter. Increasing resolution leads clusters. notice high stability four methods low number clusters. Starting k = 8, Leiden SLM perform better Louvain Louvain refined.  stats can summarised using functions mean median overall displayed can visualised following plot. utility figure proven task choosing clustering method overall stable. case, SLM stable clustering method.  resulting object can visualized plot_k_resolution_corresp shown code ; showcase relationship number clusters resolution value. plot also provides information suitable resolution values predefined number clusters. colour gradient represents either frequency partitions k clusters ECC . can also used proxy describe co-variation (k, resolution). Lighter (higher) values indicate little variation observed, changes random seed, number clusters resolution value. size illustrates frequency common partition resolution number clusters values fixed.   following plot showcases co-variation stability number clusters number different partitions resulting changes seed resolution parameter. high number different partitions indicates lower stability given number clusters. colour gradient proportional frequency common partition fixed number clusters ECC indicator robustness. size indicates frequency partition k clusters relative total number runs provide additional information whether behaviour described colour replicated multiple instances . note , even obtain high number different partitions, frequency common one close 1, overall stability high. Observing high number partitions, low frequency, indicates high instability. SLM clustering, k = 3, 4, 5, 6, 7, 8, 9 stable choices number clusters used downstream analysis.   Close connections opened using multiple cores. conclude summarizing runtime executing step assessment pipeline. results observed systems may vary; runtime also affected size date (.e number cells features), data actual values various parameters.","code":"adj_matrix <- FindNeighbors(pbmc3k@reductions$pca@cell.embeddings, k.param = 15, nn.method = \"rann\", verbose = F)$snn clustering_stability <- assess_clustering_stability(     graph_adjacency_matrix = adj_matrix,     resolution = seq(from = 0.1, to = 2, by = 0.1),     n_repetitions = n_repetitions,     clustering_algorithm = 1:4,     ecs_thresh = 1 ) #> using environment: r-reticulate #> conda environment r-reticulate installed #> install dependencies (yes/no)? #> no (use interactive mode) #> Unable to install python modules igraph and leidenalg #> run in terminal: #> conda install -n r-reticulate -c conda-forge leidenalg python-igraph pandas umap-learn #> python modules igraph and leidenalg installed wrap_plots(   list(     plot_clustering_per_value_stability(clustering_stability, \"k\") +       theme(         legend.position = c(1, 0),         legend.justification = c(1, 0)       ),     plot_clustering_per_value_stability(clustering_stability, \"resolution\") +       theme(         legend.position = c(1, 0),         legend.justification = c(1, 0)       )   ), nrow = 1) wrap_plots(list(   plot_clustering_overall_stability(clustering_stability, \"k\") +       theme(         legend.position = c(1, 0),         legend.justification = c(1, 0)       ),   plot_clustering_overall_stability(clustering_stability, \"resolution\", mean) + # function(x) { quantile(x, probs = 0.25)[[1]]})       theme(         legend.position = c(1, 0),         legend.justification = c(1, 0)       ) ), nrow = 1) plot_k_resolution_corresp(clustering_stability, dodge_width = 0.7, summary_function = min) +     plot_annotation(title = \"resolution - k correspondence with ecs threshold = 1\") plot_k_resolution_corresp(clustering_stability, dodge_width = 0.7, colour_information = \"freq_k\") +     plot_annotation(title = \"resolution - k correspondence with ecs threshold = 1\") plot_k_n_partitions(clustering_stability, dodge_width = 0.5) + plot_annotation(title = \"k - # partitions correspondence with ecs threshold = 1\") plot_k_n_partitions(clustering_stability, dodge_width = 0.5, colour_information = \"freq_part\") + plot_annotation(title = \"k - # partitions correspondence with ecs threshold = 1\") foreach::registerDoSEQ() paste(     \"Feature stability methods runtime:\",     format(as.numeric(stop_time_feature_stability - start_time_feature_stability,         units = \"mins\"     )), \"minutes\" ) #> [1] \"Feature stability methods runtime: 2.869283 minutes\" paste(     \"NN - # connected components methods runtime:\",     format(as.numeric(stop_time_nn_conn - start_time_nn_conn,         units = \"mins\"     )), \"minutes\" ) #> [1] \"NN - # connected components methods runtime: 0.443315 minutes\" paste(     \"NN stability methods runtime:\",     format(as.numeric(stop_time_nn_importance - start_time_nn_importance,         units = \"mins\"     )), \"minutes\" ) #> [1] \"NN stability methods runtime: 1.602403 minutes\" paste(     \"Clustering stability methods runtime:\",     format(as.numeric(stop_time_clustering - start_time_clustering,         units = \"mins\"     )), \"minutes\" ) #> [1] \"Clustering stability methods runtime: 4.633918 minutes\""},{"path":"https://core-bioinformatics.github.io/ClustAssess/articles/stability-pipeline-description.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info","title":"Stability-based parameter assessment","text":"","code":"sessionInfo() #> R version 4.4.0 (2024-04-24) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 22.04.4 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: Europe/Bucharest #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #>  [1] leiden_0.4.3.1                ClustAssess_1.0.0             #>  [3] ggplot2_3.5.1.9000            Seurat_5.2.0                  #>  [5] SeuratObject_5.0.2            sp_2.1-4                      #>  [7] Matrix_1.7-2                  patchwork_1.3.0               #>  [9] pbmcMultiome.SeuratData_0.1.4 pbmc3k.SeuratData_3.1.4       #> [11] SeuratData_0.2.2.9001         RhpcBLASctl_0.23-42           #> [13] devtools_2.4.5                usethis_3.1.0                 #>  #> loaded via a namespace (and not attached): #>   [1] RColorBrewer_1.1-3     jsonlite_1.8.9         magrittr_2.0.3         #>   [4] ggbeeswarm_0.7.2       spatstat.utils_3.1-2   farver_2.1.2           #>   [7] rmarkdown_2.29         fs_1.6.5               ragg_1.3.3             #>  [10] vctrs_0.6.5            ROCR_1.0-11            memoise_2.0.1          #>  [13] spatstat.explore_3.3-4 progress_1.2.3         htmltools_0.5.8.1      #>  [16] sass_0.4.9             sctransform_0.4.1      parallelly_1.41.0      #>  [19] KernSmooth_2.23-26     bslib_0.8.0            htmlwidgets_1.6.4      #>  [22] desc_1.4.3             ica_1.0-3              plyr_1.8.9             #>  [25] plotly_4.10.4          zoo_1.8-12             cachem_1.1.0           #>  [28] igraph_2.1.4           iterators_1.0.14       mime_0.12              #>  [31] lifecycle_1.0.4        pkgconfig_2.0.3        R6_2.5.1               #>  [34] fastmap_1.2.0          fitdistrplus_1.2-2     future_1.34.0          #>  [37] shiny_1.10.0           digest_0.6.37          colorspace_2.1-1       #>  [40] rprojroot_2.0.4        tensor_1.5             RSpectra_0.16-2        #>  [43] irlba_2.3.5.1          pkgload_1.4.0          textshaping_1.0.0      #>  [46] labeling_0.4.3         progressr_0.15.1       spatstat.sparse_3.1-0  #>  [49] httr_1.4.7             polyclip_1.10-7        abind_1.4-8            #>  [52] compiler_4.4.0         here_1.0.1             remotes_2.5.0          #>  [55] withr_3.0.2            fastDummies_1.7.5      pkgbuild_1.4.6         #>  [58] MASS_7.3-64            rappdirs_0.3.3         sessioninfo_1.2.2      #>  [61] tools_4.4.0            vipor_0.4.7            lmtest_0.9-40          #>  [64] beeswarm_0.4.0         httpuv_1.6.15          future.apply_1.11.3    #>  [67] goftest_1.2-3          glue_1.8.0             nlme_3.1-166           #>  [70] promises_1.3.2         grid_4.4.0             Rtsne_0.17             #>  [73] cluster_2.1.8          reshape2_1.4.4         generics_0.1.3         #>  [76] gtable_0.3.6           spatstat.data_3.1-4    tidyr_1.3.1            #>  [79] hms_1.1.3              data.table_1.16.4      BiocGenerics_0.52.0    #>  [82] spatstat.geom_3.3-5    RcppAnnoy_0.0.22       foreach_1.5.2          #>  [85] ggrepel_0.9.6          RANN_2.6.2             pillar_1.10.1          #>  [88] stringr_1.5.1          spam_2.11-1            RcppHNSW_0.6.0         #>  [91] later_1.4.1            splines_4.4.0          dplyr_1.1.4            #>  [94] lattice_0.22-6         survival_3.8-3         deldir_2.0-4           #>  [97] tidyselect_1.2.1       miniUI_0.1.1.1         pbapply_1.7-2          #> [100] knitr_1.49             gridExtra_2.3          scattermore_1.2        #> [103] xfun_0.50              SharedObject_1.20.0    matrixStats_1.5.0      #> [106] stringi_1.8.4          lazyeval_0.2.2         yaml_2.3.10            #> [109] evaluate_1.0.3         codetools_0.2-20       tibble_3.2.1           #> [112] cli_3.6.3              uwot_0.2.2             xtable_1.8-4           #> [115] reticulate_1.40.0      systemfonts_1.2.1      munsell_0.5.1          #> [118] jquerylib_0.1.4        Rcpp_1.0.14            globals_0.16.3         #> [121] spatstat.random_3.3-2  png_0.1-8              ggrastr_1.0.2          #> [124] spatstat.univar_3.1-1  parallel_4.4.0         ellipsis_0.3.2         #> [127] pkgdown_2.1.1          prettyunits_1.2.0      dotCall64_1.2          #> [130] profvis_0.4.0          urlchecker_1.0.1       listenv_0.9.1          #> [133] viridisLite_0.4.2      scales_1.3.0           ggridges_0.5.6         #> [136] crayon_1.5.3           purrr_1.0.2            rlang_1.1.5            #> [139] cowplot_1.1.3"},{"path":"https://core-bioinformatics.github.io/ClustAssess/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Andi Munteanu. Author, maintainer. Arash Shahsavari. Author. Rafael Kollyfas. Contributor. Miguel Larraz Lopez de Novales. Author. Liviu Ciortuz. Contributor. Irina Mohorianu. Author.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Shahsavari, ., Munteanu, ., & Mohorianu, (2022). ClustAssess: Tools Assessing Clustering. bioRxiv. https://doi.org/10.1101/2022.01.31.478592","code":"@Article{,   title = {ClustAssess: tools for assessing the robustness of single-cell clustering},   author = {Arash Shahsavari and Andi Munteanu and Irina Mohorianu},   journal = {bioRxiv},   year = {2022},   doi = {10.1101/2022.01.31.478592},   url = {https://doi.org/10.1101/2022.01.31.478592}, }"},{"path":"https://core-bioinformatics.github.io/ClustAssess/index.html","id":"clustassess-tools-for-assessing-clustering","dir":"","previous_headings":"","what":"Tools for Assessing Clustering","title":"Tools for Assessing Clustering","text":"repo contains ClustAssess R package, provides set tools evaluating clustering robustness. Please check ClustAssessPy module Python implementation ClustAssess package. Proportion Ambiguously Clustered Pairs (PAC) Element Centric Clustering Similarity (ECS) Marker Gene Overlap Stability-Based Parameter Assessment Interactive Visualization Stability Assessment Downstream Analysis Handling Large Datasets Installation Citing ClustAssess References","code":""},{"path":[]},{"path":"https://core-bioinformatics.github.io/ClustAssess/index.html","id":"proportion-of-ambiguously-clustered-pairs-pac","dir":"","previous_headings":"","what":"Proportion of Ambiguously Clustered Pairs (PAC)","title":"Tools for Assessing Clustering","text":"assess clustering robustness, proportion ambiguously clustered pairs (PAC) [1] uses consensus clustering. rate element co-clustering recorded across various numbers clusters, k. lower PAC, stabler clustering k. ClustAssess uses heirarchical clustering base consensus clustering, optimized Rcpp [2] implementation compute PAC values. calculate PAC, write: cc_res = consensus_cluster(your_data, n_reps=50, k_max=20, p_sample=0.8, p_feature=0.8) important PAC converged using assess data; pac_convergence function can used visualize PAC curves across iterations:  curves evened , surmize PAC converged case. PAC converged, increase n_reps value. dataset contains >1000 elements, recommend calculating geometric sketch [3] data size <1000, running PAC sketch. local minimum PAC landscape, visualized using pac_landscape function, can interpreted optimal k dataset:","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/index.html","id":"element-centric-clustering-similarity-ecs","dir":"","previous_headings":"","what":"Element Centric Clustering Similarity (ECS)","title":"Tools for Assessing Clustering","text":"Element-centric similarity (ECS) [4] per-observation measure clustering similarity. Briefly, ECS obtained constructing cluster-induced element graph, subsequently calculating stationary probability distribution random walk restarts (also known personalized Pagerank) elements. addition providing per-element information clustering agreement, ECS avoids several pitfalls associated measures clustering similarity (refer [4] detail). compare two clusterings ECS, use element_sim_elscore function: ecs = element_sim_elscore(clustering_result1, clustering_result2, alpha=0.9) 1-alpha restart probability random walk. can subsequently visualize ECS PCA data:  addition flat disjoint clusterings (like result k-means example), ClustAssess can also compare overlapping clusterings hierarchical clusterings; refer comparing-soft--hierarchical vignette detail. Besides comparing two clusterings element_sim_elscore, ClustAssess also enables computing per-element consistency (aka frustration) set clusterings element_consistency function, comparing set clusterings ground truth partitioning elements element_agreement function.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/index.html","id":"marker-gene-overlap","dir":"","previous_headings":"","what":"Marker Gene Overlap","title":"Tools for Assessing Clustering","text":"analysis single-cell RNA-seq data, cluster marker genes typically used infer cell type clusters. However, two different clustering results may lead two different sets markers cells. marker_overlap function allows comparison two sets markers. output can either number common marker genes per cell, Jaccard similarity (size intersect divided size union) per cell.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/index.html","id":"stability-based-parameter-assessment","dir":"","previous_headings":"","what":"Stability-Based Parameter Assessment","title":"Tools for Assessing Clustering","text":"common clustering pipeline single-cell data consists constructing nearest-neighbor graph cells, followed community detection obtain clustering. pipeline available multiple single-cell toolkits, including Seurat, Monocle v3, SCANPY. ClustAssess provides several methods assess stability parameter choices influence final clustering, example evaluate feature sets, use get_feature_stability_object, plot results plot_feature_stability_boxplot:  higher element-centric consistency (ECC) indicates stable clustering results across random seeds. details, please see vignette.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/index.html","id":"interactive-visualization-of-the-stability-assessment-and-downstream-analysis","dir":"","previous_headings":"","what":"Interactive Visualization of the Stability Assessment and Downstream Analysis","title":"Tools for Assessing Clustering","text":"Another feature package consists providing Shiny application user can interactively visualize stability assessment clustering perform downstream analysis steps dataset without prior R knwoledge. application divided three major components: - Stability Assessments: user presented assessment clustering stability three steps PhenoGraph pipeline. component structured three tabs, one step. user prompted select stable configurations order proceed next section. - Comparison configuration downstream analysis: user can visually assess clustering results pattern expression based variety visualisations provided section, contains UMAP plots (- one multiple gene expression, B - metadata distribution), violin boxplots (G), gene expression pseudobulk heatmap bubbleplots (E), metadata association heatmaps (C). biological interpretation enhanced possibility identifying marker genes cluster (F) enrichment analysis detected differentially expressed genes (H). app allows custom annotation clusters already existing metadata (D). - Sandbox: tab provides flexibility user temrs selected configuration. approach available, encouraged, results might stable reproducible. tab also contains elements panels changing colourscheme figures. application can generated using output automatic_stability_assessment function normalised expression matrix.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/index.html","id":"handling-large-datasets","dir":"","previous_headings":"","what":"Handling Large Datasets","title":"Tools for Assessing Clustering","text":"dataset large, runtime tools described may prohibitive. cases, recommend subsampling data using geometric sketching [3]. R, subsampling can done via reticulate: geosketch <- reticulate::import('geosketch') assuming data.embed contains dimensionality reduction data, can call: sketch.indices <- geosketch$gs(data.embed, sketch.size, one_indexed = TRUE) use resulting indices subsample. PAC, subsampling <1000 cells help, ECS data assessment functions, <5000 cells may appropriate (parallelization can help reduce runtime).","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Tools for Assessing Clustering","text":"ClustAssess can installed CRAN: install.packages(\"ClustAssess\") github using remotes: remotes::install_github(\"Core-Bioinformatics/ClustAssess\") following packages required ClustAssess: ComplexHeatmap dplyr DT fastcluster foreach glue Gmedian ggnewscale ggplot2 ggrastr ggrepel ggtext gprofiler2 igraph jsonlite leiden Matrix (>= 1.5.0) matrixStats methods progress stringr paletteer plotly qualpalr RANN reshape2 rlang Seurat shiny shinyjs shinyLP shinyWidgets stats uwot vioplot use stability-based assessment methods, run examples vignettes, following packages also needed: colourpicker dbscan DelayedMatrixStats dendextend devtools doParallel doRNG e1071 knitr leidenbase monocle3 patchwork ragg reactlog rhdf5 rmarkdown RhpcBLASctl scales SeuratData SeuratObject SharedObject styler testthat manually install required dependencies, please use following commands: manually install suggested dependencies, please use following commands: manually install packages exclusively used build vignettes, please use following commands: Note: package active development, release branches might contain additional features bug fixes.","code":"install.packages(c(\"dplyr\", \"DT\", \"fastcluster\", \"foreach\", \"glue\", \"Gmedian\", \"ggnewscale\", \"ggplot2\", \"ggrastr\", \"ggrepel\", \"ggtext\", \"gprofiler2\", \"igraph\", \"jsonlite\", \"leiden\", \"Matrix\", \"matrixStats\", \"methods\", \"progress\", \"stringr\", \"paletteer\", \"plotly\", \"qualpalr\", \"RANN\", \"reshape2\", \"rlang\", \"Seurat\", \"shiny\", \"shinyjs\", \"shinyLP\", \"shinyWidgets\", \"stats\", \"uwot\", \"vioplot\"), Ncpus = 1) install.packages(\"BiocManager\") BiocManager::install(c(\"ComplexHeatmap\")) install.packages(c(\"colourpicker\", \"devtools\", \"doParallel\", \"doRNG\", \"knitr\", \"leidenbase\", \"patchwork\", \"ragg\", \"rmarkdown\", \"RhpcBLASctl\", \"scales\", \"SeuratObject\", \"styler\", \"testthat\"), Ncpus = 1)  install.packages(\"BiocManager\") BiocManager::install(c(\"DelayedMatrixStats\", \"rhdf5\"))  devtools::install_github('cole-trapnell-lab/monocle3') devtools::install_github(\"Jiefei-Wang/SharedObject\") devtools::install_github('satijalab/seurat-data') install.packages(c(\"harmony\", \"Signac\")) BiocManager::install(\"Rsamtools\")"},{"path":"https://core-bioinformatics.github.io/ClustAssess/index.html","id":"citing-clustassess","dir":"","previous_headings":"","what":"Citing ClustAssess","title":"Tools for Assessing Clustering","text":"used ClustAssess work, please cite Shahsavari et al. 2022: BibTex:","code":"Shahsavari, A., Munteanu, A., & Mohorianu, I. (2022). ClustAssess: Tools for Assessing the Robustness of Single-Cell Clustering. bioRxiv. https://doi.org/10.1101/2022.01.31.478592 @ARTICLE{clustassess,   title     = \"ClustAssess: Tools for Assessing the Robustness of Single-Cell Clustering\",   author    = \"Shahsavari, Arash and Munteanu, Andi and Mohorianu, Irina\",   journal   = \"bioRxiv\",   year      =  2022,   url       = \"https://doi.org/10.1101/2022.01.31.478592\",   language  = \"en\" }"},{"path":"https://core-bioinformatics.github.io/ClustAssess/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Tools for Assessing Clustering","text":"[1] Șenbabaoğlu, Y., Michailidis, G., & Li, J. Z. (2014). Critical limitations consensus clustering class discovery. Scientific reports, 4(1), 1-13. https://doi.org/10.1038/srep06207 [2] Eddelbuettel, D., & Balamuta, J. J. (2018). Extending R C++: brief introduction Rcpp. American Statistician, 72(1), 28-36. https://doi.org/10.1080/00031305.2017.1375990 [3] Hie, B., Cho, H., DeMeo, B., Bryson, B., & Berger, B. (2019). Geometric sketching compactly summarizes single-cell transcriptomic landscape. Cell systems, 8(6), 483-493. https://doi.org/10.1016/j.cels.2019.05.003 [4] Gates, . J., Wood, . B., Hetrick, W. P., & Ahn, Y. Y. (2019). Element-centric clustering comparison unifies overlaps hierarchy. Scientific reports, 9(1), 1-13. https://doi.org/10.1038/s41598-019-44892-y","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/Clustering-class.html","id":null,"dir":"Reference","previous_headings":"","what":"The Clustering Class — Clustering-class","title":"The Clustering Class — Clustering-class","text":"class containing relevant data comparing clusterings, including affinity matrix Clustering.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/Clustering-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"The Clustering Class — Clustering-class","text":"names character vector element names; 1:n_elements names available creating Clustering object. n_elements numeric giving number elements. is_hierarchical logical indicating whether clustering hierarchical flat. is_disjoint logical indicating whether clustering disjoint overlapping. alpha numeric giving personalized PageRank damping factor; 1 - alpha restart probability PPR random walk. r numeric hierarchical scaling parameter. elm2clu_dict list giving clusters element member . clu2elm_dict list giving element members cluster. affinity_matrix Matrix containing personalized pagerank equilibrium distribution.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/add_metadata.html","id":null,"dir":"Reference","previous_headings":"","what":"Add metadata to ClustAssess ShinyApp — add_metadata","title":"Add metadata to ClustAssess ShinyApp — add_metadata","text":"Adds new metadata ClustAssess ShinyApp without update object re-create app.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/add_metadata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add metadata to ClustAssess ShinyApp — add_metadata","text":"","code":"add_metadata(app_folder, metadata, qualpalr_colorspace = \"pretty\")"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/add_metadata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add metadata to ClustAssess ShinyApp — add_metadata","text":"app_folder folder containing ClustAssess ShinyApp metadata new metadata added. parameter dataframe follows row ordering already existing metadata ClustAssess app. qualpalr_colorspace colorspace used metadata","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/add_metadata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add metadata to ClustAssess ShinyApp — add_metadata","text":"NULL - metadata object updated app folder","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/assess_clustering_stability.html","id":null,"dir":"Reference","previous_headings":"","what":"Assessment of Stability for Graph Clustering — assess_clustering_stability","title":"Assessment of Stability for Graph Clustering — assess_clustering_stability","text":"Evaluates stability different graph clustering methods clustering pipeline. method iterate different values resolution parameter compare, using EC Consistency score, partitions obtained different seeds.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/assess_clustering_stability.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assessment of Stability for Graph Clustering — assess_clustering_stability","text":"","code":"assess_clustering_stability(   graph_adjacency_matrix,   resolution,   n_repetitions = 100,   seed_sequence = NULL,   ecs_thresh = 1,   clustering_algorithm = 1:3,   clustering_arguments = list(),   verbose = TRUE )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/assess_clustering_stability.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assessment of Stability for Graph Clustering — assess_clustering_stability","text":"graph_adjacency_matrix square adjacency matrix based igraph object built. matrix rownames colnames correspond names cells. resolution sequence resolution values. resolution parameter controls coarseness clustering. higher resolution, clusters obtained. resolution parameter used community detection algorithms. n_repetitions number repetitions applying pipeline different seeds; ignored seed_sequence provided user. Defaults 100. seed_sequence custom seed sequence; value NULL, sequence built starting 1 step 100. ecs_thresh ECS threshold used merging similar clusterings. clustering_algorithm index list indexes indicating community detection algorithm used: Louvain (1), Louvain refined (2), SLM (3) Leiden (4). details can found Seurat's FindClusters function. Defaults 1:3. clustering_arguments list additional arguments passed clustering method. details can found Seurat's FindClusters function. verbose Boolean value used displaying progress bar.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/assess_clustering_stability.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assessment of Stability for Graph Clustering — assess_clustering_stability","text":"list two fields: - list contains, clustering method resolution value, EC consistency partitions obtained changing seed filtered - similar , configuration, determine number clusters appears use partitions size","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/assess_clustering_stability.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Assessment of Stability for Graph Clustering — assess_clustering_stability","text":"","code":"set.seed(2024) # create an artificial PCA embedding pca_embedding <- matrix(runif(100 * 30), nrow = 100) rownames(pca_embedding) <- paste0(\"cell_\", seq_len(nrow(pca_embedding))) colnames(pca_embedding) <- paste0(\"PC_\", 1:30)   adj_matrix <- getNNmatrix(     RANN::nn2(pca_embedding, k = 10)$nn.idx,     10,     0,     -1 )$nn rownames(adj_matrix) <- paste0(\"cell_\", seq_len(nrow(adj_matrix))) colnames(adj_matrix) <- paste0(\"cell_\", seq_len(ncol(adj_matrix)))  # alternatively, the adj_matrix can be calculated # using the `Seurat::FindNeighbors` function.  clust_diff_obj <- assess_clustering_stability(     graph_adjacency_matrix = adj_matrix,     resolution = c(0.5, 1),     n_repetitions = 10,     clustering_algorithm = 1:2,     verbose = TRUE ) #> Warning: executing %dopar% sequentially: no parallel backend registered plot_clustering_overall_stability(clust_diff_obj)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/assess_feature_stability.html","id":null,"dir":"Reference","previous_headings":"","what":"Assess the stability for configurations of feature types and sizes — assess_feature_stability","title":"Assess the stability for configurations of feature types and sizes — assess_feature_stability","text":"Evaluate stability clusterings obtained based incremental subsets given feature set.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/assess_feature_stability.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assess the stability for configurations of feature types and sizes — assess_feature_stability","text":"","code":"assess_feature_stability(   data_matrix,   feature_set,   steps,   feature_type,   resolution,   n_repetitions = 100,   seed_sequence = NULL,   graph_reduction_type = \"PCA\",   ecs_thresh = 1,   matrix_processing = function(dt_mtx, actual_npcs = 30, ...) {      actual_npcs <-     min(actual_npcs, ncol(dt_mtx)%/%2)          RhpcBLASctl::blas_set_num_threads(foreach::getDoParWorkers())      embedding <- stats::prcomp(x = dt_mtx, rank. = actual_npcs)$x          RhpcBLASctl::blas_set_num_threads(1) rownames(embedding) <- rownames(dt_mtx)     colnames(embedding) <- paste0(\"PC_\", seq_len(ncol(embedding)))          return(embedding)  },   umap_arguments = list(),   prune_value = -1,   clustering_algorithm = 1,   clustering_arguments = list(),   verbose = FALSE )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/assess_feature_stability.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assess the stability for configurations of feature types and sizes — assess_feature_stability","text":"data_matrix data matrix features rows observations columns. feature_set set feature names can found rownames data matrix. steps Vector containing sizes subsets; negative values interpreted using features. feature_type name associated feature_set. resolution vector containing resolution values used clustering. n_repetitions number repetitions applying pipeline different seeds; ignored seed_sequence provided user. Defaults 100. seed_sequence custom seed sequence; value NULL, sequence built starting 1 step 100. Defaults NULL. graph_reduction_type graph reduction type, denoting graph built either PCA UMAP embedding. Defaults PCA. ecs_thresh ECS threshold used merging similar clusterings. recommend using 1 value. Defaults 1. matrix_processing function used process data matrix using dimensionality reduction technique. function one parameter, data matrix, return embedding describing reduced space. default, function use precise PCA method prcomp. umap_arguments list containing arguments passed UMAP function. Refer uwot::umap function details. prune_value Argument indicating whether prune SNN graph. value 0, graph pruned. value 0 1, edges weight pruning value removed. value -1, highest pruning value calculated automatically used. clustering_algorithm index indicating community detection algorithm used: Louvain (1), Louvain refined (2), SLM (3) Leiden (4). details can found Seurat's FindClusters function. clustering_arguments list containing arguments passed community detection algorithm, number iterations number starts. Refer Seurat's FindClusters function details. verbose boolean indicating intermediate progress printed .","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/assess_feature_stability.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assess the stability for configurations of feature types and sizes — assess_feature_stability","text":"list one field associated step value. step contains list three fields: ecc - EC-Consistency partitions obtained repetitions embedding - one UMAP embedding generated feature subset most_frequent_partition - common partition obtained across repetitions","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/assess_feature_stability.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Assess the stability for configurations of feature types and sizes — assess_feature_stability","text":"algorithm assumes feature_set already sorted performing subsetting based steps values. example, user wants analyze highly variable feature set, provide sorted variability.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/assess_feature_stability.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Assess the stability for configurations of feature types and sizes — assess_feature_stability","text":"","code":"set.seed(2024) # create an artificial expression matrix expr_matrix <- matrix(     c(runif(100 * 10), runif(100 * 10, min = 3, max = 4)),     nrow = 200, byrow = TRUE ) rownames(expr_matrix) <- as.character(1:200) colnames(expr_matrix) <- paste(\"feature\", 1:10)  feature_stability_result <- assess_feature_stability(     data_matrix = t(expr_matrix),     feature_set = colnames(expr_matrix),     steps = 5,     feature_type = \"feature_name\",     resolution = c(0.1, 0.5, 1),     n_repetitions = 10,     umap_arguments = list(         # the following parameters are used by the umap function         # and are not mandatory         n_neighbors = 3,         approx_pow = TRUE,         n_epochs = 0,         init = \"random\",         min_dist = 0.3     ),     clustering_algorithm = 1 ) plot_feature_overall_stability_boxplot(feature_stability_result)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/assess_nn_stability.html","id":null,"dir":"Reference","previous_headings":"","what":"Assess the stability for Graph Building Parameters — assess_nn_stability","title":"Assess the stability for Graph Building Parameters — assess_nn_stability","text":"Evaluates clustering stability changing values different parameters involved graph building step, namely base embedding, graph type number neighbours.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/assess_nn_stability.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assess the stability for Graph Building Parameters — assess_nn_stability","text":"","code":"assess_nn_stability(   embedding,   n_neigh_sequence,   n_repetitions = 100,   seed_sequence = NULL,   graph_reduction_type = \"PCA\",   ecs_thresh = 1,   graph_type = 2,   prune_value = -1,   clustering_algorithm = 1,   clustering_arguments = list(),   umap_arguments = list() )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/assess_nn_stability.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assess the stability for Graph Building Parameters — assess_nn_stability","text":"embedding matrix associated PCA embedding. Embeddings dimensionality reduction techniques (LSI) can used. n_neigh_sequence sequence number nearest neighbours. n_repetitions number repetitions applying pipeline different seeds; ignored seed_sequence provided user. seed_sequence custom seed sequence; value NULL, sequence built starting 1 step 100. graph_reduction_type graph reduction type, denoting graph built either PCA UMAP embedding. ecs_thresh ECS threshold used merging similar clusterings. graph_type Argument indicating whether graph unweighted (0), weighted (1) (2). prune_value Argument indicating whether prune SNN graph. value 0, graph pruned. value 0 1, edges weight pruning value removed. value -1, highest pruning value calculated automatically used. clustering_algorithm index indicating community detection algorithm used: Louvain (1), Louvain refined (2), SLM (3) Leiden (4). details can found Seurat's FindClusters function. clustering_arguments list arguments passed clustering algorithm. See FindClusters function Seurat details. umap_arguments Additional arguments passed uwot::umap method.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/assess_nn_stability.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assess the stability for Graph Building Parameters — assess_nn_stability","text":"list three fields: n_neigh_k_corresp - list containing number clusters obtained running pipeline multiple times different seed, number neighbours graph type (weighted vs unweigted) n_neigh_ec_consistency - list containing EC consistency partitions obtained multiple runs changing number neighbours graph type n_different_partitions - number different partitions obtained number neighbours","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/assess_nn_stability.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Assess the stability for Graph Building Parameters — assess_nn_stability","text":"","code":"set.seed(2024) # create an artificial PCA embedding pca_emb <- matrix(runif(100 * 30), nrow = 100, byrow = TRUE) rownames(pca_emb) <- as.character(1:100) colnames(pca_emb) <- paste0(\"PC_\", 1:30)  nn_stability_obj <- assess_nn_stability(     embedding = pca_emb,     n_neigh_sequence = c(10, 15, 20),     n_repetitions = 10,     graph_reduction_type = \"PCA\",     clustering_algorithm = 1 ) plot_n_neigh_ecs(nn_stability_obj)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/automatic_stability_assessment.html","id":null,"dir":"Reference","previous_headings":"","what":"Assessment of Stability for Graph Clustering — automatic_stability_assessment","title":"Assessment of Stability for Graph Clustering — automatic_stability_assessment","text":"Evaluates stability different graph clustering methods clustering pipeline. method iterate different values resolution parameter compare, using EC Consistency score, partitions obtained different seeds.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/automatic_stability_assessment.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assessment of Stability for Graph Clustering — automatic_stability_assessment","text":"","code":"automatic_stability_assessment(   expression_matrix,   n_repetitions,   n_neigh_sequence,   resolution_sequence,   features_sets,   steps,   seed_sequence = NULL,   graph_reduction_embedding = \"PCA\",   include_umap_nn_assessment = FALSE,   n_top_configs = 3,   ranking_criterion = \"iqr\",   overall_summary = \"median\",   ecs_threshold = 1,   matrix_processing = function(dt_mtx, actual_npcs = 30, ...) {      actual_npcs <-     min(actual_npcs, ncol(dt_mtx)%/%2)          RhpcBLASctl::blas_set_num_threads(foreach::getDoParWorkers())      embedding <- stats::prcomp(x = dt_mtx, rank. = actual_npcs)$x          RhpcBLASctl::blas_set_num_threads(1) rownames(embedding) <- rownames(dt_mtx)     colnames(embedding) <- paste0(\"PC_\", seq_len(ncol(embedding)))          return(embedding)  },   umap_arguments = list(),   prune_value = -1,   algorithm_dim_reduction = 1,   algorithm_graph_construct = 1,   algorithms_clustering_assessment = 1:3,   clustering_arguments = list(),   verbose = TRUE,   temp_file = NULL,   save_temp = TRUE )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/automatic_stability_assessment.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assessment of Stability for Graph Clustering — automatic_stability_assessment","text":"expression_matrix expression matrix features rows cells columns. n_repetitions number repetitions applying pipeline different seeds; ignored seed_sequence provided user. Defaults 100. n_neigh_sequence sequence number nearest neighbours. resolution_sequence sequence resolution values. resolution parameter controls coarseness clustering. higher resolution, clusters obtained. resolution parameter used community detection algorithms. features_sets list feature sets. feature set list genes expression matrix used dimensionality reduction. steps list names feature_sets. name assigned ector containing sizes subsets; negative values interpreted using features. seed_sequence custom seed sequence; value NULL, sequence built starting 1 step 100. graph_reduction_embedding type dimensionality reduction used graph construction. options \"PCA\" \"UMAP\". Defaults PCA. include_umap_nn_assessment boolean value indicating UMAP embeddings used nearest neighbours assessment. Defaults FALSE. n_top_configs number top configurations used downstream analysis dimensionality reduction step. Defaults 3. ranking_criterion criterion used ranking configurations dimensionality reduction step. options \"iqr\", \"median\", \"max\", \"top_qt\", \"top_qt_max\", \"iqr_median\", \"iqr_median_coeff\" \"mean\". Defaults iqr. overall_summary function used summarize stability configurations dimensionality reduction step across different resolution values. options \"median\", \"max\", \"top_qt\", \"top_qt_max\", \"iqr\", \"iqr_median\", \"iqr_median_coeff\" \"mean\". Defaults median. ecs_threshold ECS threshold used merging similar clusterings. matrix_processing function used process data matrix using dimensionality reduction technique. function one parameter, data matrix, return embedding describing reduced space. default, function use precise PCA method prcomp. umap_arguments list containing arguments passed UMAP function. Refer uwot::umap function details. prune_value Argument indicating whether prune SNN graph. value 0, graph pruned. value 0 1, edges weight pruning value removed. value -1, highest pruning value calculated automatically used. algorithm_dim_reduction index indicating community detection algorithm used Dimensionality reduction step. algorithm_graph_construct index indicating community detection algorithm used Graph construction step. algorithms_clustering_assessment index indicating community detection algorithm used clustering step: Louvain (1), Louvain refined (2), SLM (3) Leiden (4). details can found Seurat's FindClusters function. clustering_arguments list containing arguments passed community detection algorithm, number iterations number starts. Refer Seurat's FindClusters function details. verbose Boolean value used displaying progress assessment. temp_file path file object saved. save_temp boolean value indicating object saved file.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/automatic_stability_assessment.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assessment of Stability for Graph Clustering — automatic_stability_assessment","text":"list two fields: - list contains, clustering method resolution value, EC consistency partitions obtained changing seed filtered - similar , configuration, determine number clusters appears use partitions size","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/automatic_stability_assessment.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Assessment of Stability for Graph Clustering — automatic_stability_assessment","text":"","code":"if (FALSE) { # \\dontrun{ set.seed(2024) # create an already-transposed artificial expression matrix expr_matrix <- matrix(     c(runif(20 * 10), runif(30 * 10, min = 3, max = 4)),     nrow = 10, byrow = FALSE ) colnames(expr_matrix) <- as.character(seq_len(ncol(expr_matrix))) rownames(expr_matrix) <- paste(\"feature\", seq_len(nrow(expr_matrix)))  autom_object <- automatic_stability_assessment(     expression_matrix = expr_matrix,     n_repetitions = 3,     n_neigh_sequence = c(5),     resolution_sequence = c(0.1, 0.5),     features_sets = list(         \"set1\" = rownames(expr_matrix)     ),     steps = list(         \"set1\" = c(5, 7)     ),     umap_arguments = list(         # the following parameters have been modified         # from the default values to ensure that         # the function will run under 5 seconds         n_neighbors = 3,         approx_pow = TRUE,         n_epochs = 0,         init = \"random\",         min_dist = 0.3     ),     n_top_configs = 1,     algorithms_clustering_assessment = 1,     save_temp = FALSE,     verbose = FALSE )  # the object can be further used to plot the assessment results plot_feature_overall_stability_boxplot(autom_object$feature_stability) plot_n_neigh_ecs(autom_object$set1$\"5\"$nn_stability) plot_k_n_partitions(autom_object$set1$\"5\"$clustering_stability) } # }"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/calculate_markers.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate markers — calculate_markers","title":"Calculate markers — calculate_markers","text":"Performs Wilcoxon rank sum test identify differentially expressed genes two groups cells.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/calculate_markers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate markers — calculate_markers","text":"","code":"calculate_markers(   expression_matrix,   cells1,   cells2,   logfc_threshold = 0,   min_pct_threshold = 0.1,   avg_expr_threshold_group1 = 0,   min_diff_pct_threshold = -Inf,   rank_matrix = NULL,   feature_names = NULL,   used_slot = \"data\",   norm_method = \"SCT\",   pseudocount_use = 1,   base = 2,   adjust_pvals = TRUE,   check_cells_set_diff = TRUE )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/calculate_markers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate markers — calculate_markers","text":"expression_matrix matrix gene expression values genes rows cells columns. cells1 vector cell indices first group cells. cells2 vector cell indices second group cells. logfc_threshold minimum absolute log fold change consider gene differentially expressed. Defaults 0, meaning genes taken considereation. min_pct_threshold minimum fraction cells expressing gene form cell population consider gene differentially expressed. Increasing value speed function. Defaults 0.1. avg_expr_threshold_group1 minimum average expression gene first group cells considered differentially expressed. Defaults 0. min_diff_pct_threshold minimum difference fraction cells expressing gene two cell populations consider gene differentially expressed. Defaults -Inf. rank_matrix matrix cells ranked based expression levels respect gene. Defaults NULL, case function calculate rank matrix. recommend calculating rank matrix beforehand passing function speed computation. feature_names vector gene names. Defaults NULL, case function use row names expression matrix gene names. used_slot Parameter provides additional information expression matrix, whether scaled . value parameter impacts calculation fold change. data, function calculates fold change fraction log value average expression raised exponential two cell groups. scale.data, function calculate fold change fraction average expression values two cell groups. options default calculating fold change fraction log value average expression values two cell groups. Defaults data. norm_method normalization method used normalize expression matrix. value parameter impacts calculation average expression genes used_slot = \"data\". LogNormalize, log fold change calculated described used_slot parameter. Otherwise, log fold change calculated fraction log value average expression values two cell groups. Defaults SCT. pseudocount_use pseudocount add expression values calculating average expression genes, avoid 0 value denominator. Defaults 1. base base logharithm. Defaults 2. adjust_pvals logical value indicating whether adjust p-values multiple testing using Bonferonni method. Defaults TRUE. check_cells_set_diff logical value indicating whether check thw two cell groups disjoint . Defaults TRUE.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/calculate_markers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate markers — calculate_markers","text":"data frame containing following columns: gene: gene name. avg_log2FC: average log fold change two cell groups. p_val: p-value Wilcoxon rank sum test. p_val_adj: adjusted p-value Wilcoxon rank sum test. pct.1: fraction cells expressing gene first cell group. pct.2: fraction cells expressing gene second cell group. avg_expr_group1: average expression gene first cell group.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/calculate_markers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate markers — calculate_markers","text":"","code":"set.seed(2024) # create an artificial expression matrix expr_matrix <- matrix(     c(runif(100 * 50), runif(100 * 50, min = 3, max = 4)),     ncol = 200, byrow = FALSE ) colnames(expr_matrix) <- as.character(1:200) rownames(expr_matrix) <- paste(\"feature\", 1:50)  calculate_markers(     expression_matrix = expr_matrix,     cells1 = 101:200,     cells2 = 1:100 ) #>                  gene avg_log2FC pct.1 pct.2        p_val    p_val_adj #> feature 1   feature 1   5.324445     1     1 2.562144e-34 1.281072e-32 #> feature 2   feature 2   5.586295     1     1 2.562144e-34 1.281072e-32 #> feature 3   feature 3   5.273713     1     1 2.562144e-34 1.281072e-32 #> feature 4   feature 4   5.643523     1     1 2.562144e-34 1.281072e-32 #> feature 5   feature 5   5.706965     1     1 2.562144e-34 1.281072e-32 #> feature 6   feature 6   5.487495     1     1 2.562144e-34 1.281072e-32 #> feature 7   feature 7   5.487029     1     1 2.562144e-34 1.281072e-32 #> feature 8   feature 8   5.587873     1     1 2.562144e-34 1.281072e-32 #> feature 9   feature 9   5.578639     1     1 2.562144e-34 1.281072e-32 #> feature 10 feature 10   5.433841     1     1 2.562144e-34 1.281072e-32 #> feature 11 feature 11   5.616236     1     1 2.562144e-34 1.281072e-32 #> feature 12 feature 12   5.467072     1     1 2.562144e-34 1.281072e-32 #> feature 13 feature 13   5.444738     1     1 2.562144e-34 1.281072e-32 #> feature 14 feature 14   5.550933     1     1 2.562144e-34 1.281072e-32 #> feature 15 feature 15   5.464486     1     1 2.562144e-34 1.281072e-32 #> feature 16 feature 16   5.473382     1     1 2.562144e-34 1.281072e-32 #> feature 17 feature 17   5.536340     1     1 2.562144e-34 1.281072e-32 #> feature 18 feature 18   5.553369     1     1 2.562144e-34 1.281072e-32 #> feature 19 feature 19   5.550821     1     1 2.562144e-34 1.281072e-32 #> feature 20 feature 20   5.414216     1     1 2.562144e-34 1.281072e-32 #> feature 21 feature 21   5.339008     1     1 2.562144e-34 1.281072e-32 #> feature 22 feature 22   5.486371     1     1 2.562144e-34 1.281072e-32 #> feature 23 feature 23   5.514801     1     1 2.562144e-34 1.281072e-32 #> feature 24 feature 24   5.626331     1     1 2.562144e-34 1.281072e-32 #> feature 25 feature 25   5.520828     1     1 2.562144e-34 1.281072e-32 #> feature 26 feature 26   5.439109     1     1 2.562144e-34 1.281072e-32 #> feature 27 feature 27   5.510551     1     1 2.562144e-34 1.281072e-32 #> feature 28 feature 28   5.414908     1     1 2.562144e-34 1.281072e-32 #> feature 29 feature 29   5.536102     1     1 2.562144e-34 1.281072e-32 #> feature 30 feature 30   5.471044     1     1 2.562144e-34 1.281072e-32 #> feature 31 feature 31   5.712207     1     1 2.562144e-34 1.281072e-32 #> feature 32 feature 32   5.482001     1     1 2.562144e-34 1.281072e-32 #> feature 33 feature 33   5.396843     1     1 2.562144e-34 1.281072e-32 #> feature 34 feature 34   5.458924     1     1 2.562144e-34 1.281072e-32 #> feature 35 feature 35   5.466319     1     1 2.562144e-34 1.281072e-32 #> feature 36 feature 36   5.521587     1     1 2.562144e-34 1.281072e-32 #> feature 37 feature 37   5.585943     1     1 2.562144e-34 1.281072e-32 #> feature 38 feature 38   5.537862     1     1 2.562144e-34 1.281072e-32 #> feature 39 feature 39   5.531601     1     1 2.562144e-34 1.281072e-32 #> feature 40 feature 40   5.646930     1     1 2.562144e-34 1.281072e-32 #> feature 41 feature 41   5.322801     1     1 2.562144e-34 1.281072e-32 #> feature 42 feature 42   5.709088     1     1 2.562144e-34 1.281072e-32 #> feature 43 feature 43   5.784678     1     1 2.562144e-34 1.281072e-32 #> feature 44 feature 44   5.662688     1     1 2.562144e-34 1.281072e-32 #> feature 45 feature 45   5.541069     1     1 2.562144e-34 1.281072e-32 #> feature 46 feature 46   5.445265     1     1 2.562144e-34 1.281072e-32 #> feature 47 feature 47   5.515937     1     1 2.562144e-34 1.281072e-32 #> feature 48 feature 48   5.621451     1     1 2.562144e-34 1.281072e-32 #> feature 49 feature 49   5.516103     1     1 2.562144e-34 1.281072e-32 #> feature 50 feature 50   5.515016     1     1 2.562144e-34 1.281072e-32 #>            avg_expr_group1 #> feature 1         3.497559 #> feature 2         3.496166 #> feature 3         3.445801 #> feature 4         3.504912 #> feature 5         3.577405 #> feature 6         3.525528 #> feature 7         3.485442 #> feature 8         3.506795 #> feature 9         3.476262 #> feature 10        3.484119 #> feature 11        3.498119 #> feature 12        3.493887 #> feature 13        3.471559 #> feature 14        3.498410 #> feature 15        3.511520 #> feature 16        3.537302 #> feature 17        3.482097 #> feature 18        3.507179 #> feature 19        3.493560 #> feature 20        3.431861 #> feature 21        3.465087 #> feature 22        3.477709 #> feature 23        3.487408 #> feature 24        3.527158 #> feature 25        3.513766 #> feature 26        3.469997 #> feature 27        3.462232 #> feature 28        3.501975 #> feature 29        3.491901 #> feature 30        3.515717 #> feature 31        3.466661 #> feature 32        3.534487 #> feature 33        3.483160 #> feature 34        3.481944 #> feature 35        3.504899 #> feature 36        3.521041 #> feature 37        3.508432 #> feature 38        3.471637 #> feature 39        3.521095 #> feature 40        3.505936 #> feature 41        3.480344 #> feature 42        3.528489 #> feature 43        3.516821 #> feature 44        3.487346 #> feature 45        3.502275 #> feature 46        3.484552 #> feature 47        3.528281 #> feature 48        3.517302 #> feature 49        3.513613 #> feature 50        3.482948 # TODO should be rewritten such that you don't create new matrix objects inside # just"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/calculate_markers_shiny.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate markers - Shiny — calculate_markers_shiny","title":"Calculate markers - Shiny — calculate_markers_shiny","text":"Performs Wilcoxon rank sum test identify differentially expressed genes two groups cells shiny context. method can also used outside shiny context, long expression matrix stored h5 file.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/calculate_markers_shiny.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate markers - Shiny — calculate_markers_shiny","text":"","code":"calculate_markers_shiny(   cells1,   cells2,   logfc_threshold = 0,   min_pct_threshold = 0.1,   average_expression_threshold = 0,   average_expression_group1_threshold = 0,   min_diff_pct_threshold = -Inf,   used_slot = \"data\",   norm_method = \"SCT\",   expression_h5_path = \"expression.h5\",   pseudocount_use = 1,   base = 2,   verbose = TRUE,   check_difference = TRUE )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/calculate_markers_shiny.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate markers - Shiny — calculate_markers_shiny","text":"cells1 vector cell indices first group cells. cells2 vector cell indices second group cells. logfc_threshold minimum absolute log fold change consider gene differentially expressed. Defaults 0, meaning genes taken considereation. min_pct_threshold minimum fraction cells expressing gene form cell population consider gene differentially expressed. Increasing value speed function. Defaults 0.1. average_expression_threshold minimum average expression gene order considered differentially expressed. average_expression_group1_threshold minimum average expression gene first group cells considered differentially expressed. Defaults 0. min_diff_pct_threshold minimum difference fraction cells expressing gene two cell populations consider gene differentially expressed. Defaults -Inf. used_slot Parameter provides additional information expression matrix, whether scaled . value parameter impacts calculation fold change. data, function calculates fold change fraction log value average expression raised exponential two cell groups. scale.data, function calculate fold change fraction average expression values two cell groups. options default calculating fold change fraction log value average expression values two cell groups. Defaults data. norm_method normalization method used normalize expression matrix. value parameter impacts calculation average expression genes used_slot = \"data\". LogNormalize, log fold change calculated described used_slot parameter. Otherwise, log fold change calculated fraction log value average expression values two cell groups. Defaults SCT. expression_h5_path path h5 file containing expression matrix. h5 file contain following fields: expression_matrix, rank_matrix, average_expression, genes. file path defaults expression.h5. pseudocount_use pseudocount add expression values calculating average expression genes, avoid 0 value denominator. Defaults 1. base base logharithm. Defaults 2. verbose Whether print messages progress function. Defaults TRUE. check_difference Whether perform set difference two cells. Defaults TRUE.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/calculate_markers_shiny.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate markers - Shiny — calculate_markers_shiny","text":"data frame containing following columns: gene: gene name. avg_log2FC: average log fold change two cell groups. p_val: p-value Wilcoxon rank sum test. p_val_adj: adjusted p-value Wilcoxon rank sum test. pct.1: fraction cells expressing gene first cell group. pct.2: fraction cells expressing gene second cell group. avg_expr_group1: average expression gene first cell group. avg_expr: average expression gene.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/choose_stable_clusters.html","id":null,"dir":"Reference","previous_headings":"","what":"Choose stable clusters based on ECC and frequency — choose_stable_clusters","title":"Choose stable clusters based on ECC and frequency — choose_stable_clusters","text":"Filter list clusters obtained automatic ClustAssess pipeline using ECC frequency thresholds. ECC threshold meant filter partitions highly sensitive change random seed, purpose frequency threshold assure statistical significance inferred stability.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/choose_stable_clusters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Choose stable clusters based on ECC and frequency — choose_stable_clusters","text":"","code":"choose_stable_clusters(   clusters_list,   ecc_threshold = 0.9,   freq_threshold = 30,   summary_function = mean )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/choose_stable_clusters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Choose stable clusters based on ECC and frequency — choose_stable_clusters","text":"clusters_list List clusters obtained get_clusters_from_clustassess_object function. ecc_threshold Minimum ECC value consider cluster stable. Default 0.9. freq_threshold Minimum total frequency partitions consider. Default 30. summary_function Function summarize ECC values. Default mean. match results ClustAssess Shiny App, use median.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/choose_stable_clusters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Choose stable clusters based on ECC and frequency — choose_stable_clusters","text":"list stable clusters satisfy ECC frequency.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/consensus_cluster.html","id":null,"dir":"Reference","previous_headings":"","what":"Consensus Clustering and Proportion of Ambiguously Clustered Pairs — consensus_cluster","title":"Consensus Clustering and Proportion of Ambiguously Clustered Pairs — consensus_cluster","text":"Calculate consensus clustering proportion ambiguously clustered pairs (PAC) hierarchical clustering.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/consensus_cluster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Consensus Clustering and Proportion of Ambiguously Clustered Pairs — consensus_cluster","text":"","code":"consensus_cluster(   x,   k_min = 3,   k_max = 100,   n_reps = 100,   p_sample = 0.8,   p_feature = 1,   p_minkowski = 2,   dist_method = \"euclidean\",   linkage = \"complete\",   lower_lim = 0.1,   upper_lim = 0.9,   verbose = TRUE )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/consensus_cluster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Consensus Clustering and Proportion of Ambiguously Clustered Pairs — consensus_cluster","text":"x samples x features normalized data matrix. k_min minimum number clusters calculated. k_max maximum number clusters calculated. n_reps total number subsamplings reclusterings data; value needs high enough ensure PAC converges; convergence can assessed pac_convergence. p_sample proportion samples included subsample. p_feature proportion features included subsample. p_minkowski power Minkowski distance. dist_method distance measure distance matrix used hclust; must one \"euclidean\", \"maximum\", \"manhattan\", \"canberra\", \"binary\" \"minkowski\". linkage linkage method used hclust; must one \"ward.D\", \"ward.D2\", \"single\", \"complete\", \"average\", \"mcquitty\", \"median\" \"centroid\" lower_lim lower limit determining whether pair clustered ambiguously; lower value, higher PAC. upper_lim upper limit determining whether pair clustered ambiguously; higher value, higher PAC. verbose Logical value used choosing display progress bar .","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/consensus_cluster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Consensus Clustering and Proportion of Ambiguously Clustered Pairs — consensus_cluster","text":"data.frame PAC values across iterations, well parameter values used calling method.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/consensus_cluster.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Consensus Clustering and Proportion of Ambiguously Clustered Pairs — consensus_cluster","text":"Monti, S., Tamayo, P., Mesirov, J., & Golub, T. (2003). Consensus clustering: resampling-based method class discovery visualization gene expression microarray data. Machine learning, 52(1), 91-118. https://doi.org/10.1023/:1023949509487 Senbabaoglu, Y., Michailidis, G., & Li, J. Z. (2014). Critical limitations consensus clustering class discovery. Scientific reports, 4(1), 1-13. https://doi.org/10.1038/srep06207","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/consensus_cluster.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Consensus Clustering and Proportion of Ambiguously Clustered Pairs — consensus_cluster","text":"","code":"pac.res <- consensus_cluster(iris[, 1:4], k_max = 20) #> Calculating consensus clustering pac_convergence(pac.res, k_plot = c(3, 5, 7, 9))"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/create_clustering.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Clustering Object — create_clustering","title":"Create Clustering Object — create_clustering","text":"Creates Clustering object output clustering method.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/create_clustering.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Clustering Object — create_clustering","text":"","code":"create_clustering(clustering_result, ...)  # S4 method for class 'numeric' create_clustering(clustering_result, alpha = 0.9)  # S4 method for class 'integer' create_clustering(clustering_result, alpha = 0.9)  # S4 method for class 'character' create_clustering(clustering_result, alpha = 0.9)  # S4 method for class 'factor' create_clustering(clustering_result, alpha = 0.9)  # S4 method for class 'matrix' create_clustering(   clustering_result,   alpha = 0.9,   ppr_implementation = \"prpack\",   row_normalize = TRUE )  # S4 method for class 'Matrix' create_clustering(   clustering_result,   alpha = 0.9,   ppr_implementation = \"prpack\",   row_normalize = TRUE )  # S4 method for class 'hclust' create_clustering(   clustering_result,   alpha = 0.9,   r = 1,   rescale_path_type = \"max\",   ppr_implementation = \"prpack\",   dist_rescaled = FALSE )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/create_clustering.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Clustering Object — create_clustering","text":"clustering_result clustering result, either: numeric/character/factor vector cluster labels element. samples x clusters matrix/Matrix::Matrix nonzero membership values. hclust object. ... argument used. alpha numeric giving personalized PageRank damping factor; 1 - alpha restart probability PPR random walk. ppr_implementation Choose implementation personalized page-rank calculation: \"prpack\": use PPR algorithms igraph. \"power_iteration\": use power_iteration method. row_normalize Whether normalize rows clustering_result sum one calculating ECS. recommended set TRUE, lead slightly different ECS values compared clusim. r numeric hierarchical scaling parameter. rescale_path_type string; rescale hierarchical height : \"max\" : maximum path root. \"min\" : minimum path form root. \"linkage\" : use linkage distances clustering. dist_rescaled logical: TRUE, linkage distances linearly rescaled -0 1.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/create_clustering.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Clustering Object — create_clustering","text":"Clustering object.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/create_clustering.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Create Clustering Object — create_clustering","text":"create_clustering(numeric): Create Clustering Object Numeric Vector create_clustering(integer): Create Clustering Object Integer Vector create_clustering(character): Create Clustering Object Character Vector create_clustering(factor): Create Clustering Object Factor Vector create_clustering(matrix): Create Clustering Object base matrix create_clustering(Matrix): Create Clustering Object Matrix::Matrix create_clustering(hclust): Create Clustering Object hclust","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/create_monocle_default.html","id":null,"dir":"Reference","previous_headings":"","what":"Create monocle object — create_monocle_default","title":"Create monocle object — create_monocle_default","text":"Use normalized expression matrix , potentially, already generated PCA / UMAP embedding, create Monocle object.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/create_monocle_default.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create monocle object — create_monocle_default","text":"","code":"create_monocle_default(   normalized_expression_matrix,   count_matrix = NULL,   pca_embedding = NULL,   umap_embedding = NULL,   metadata_df = NULL )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/create_monocle_default.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create monocle object — create_monocle_default","text":"normalized_expression_matrix normalized expression matrix genes rows cells columns. count_matrix count matrix genes rows cells columns. NULL, normalized_expression_matrix used. pca_embedding PCA embedding expression matrix. NULL, pca created using monocle3 package (default parameters). umap_embedding UMAP embedding expression matrix. NULL, umap created using monocle3 package (default parameters). metadata_df metadata dataframe cell names rownames. NULL, dataframe single column named identical_ident created.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/create_monocle_default.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create monocle object — create_monocle_default","text":"Monocle object expression matrix, stable number clusters identified ClustAssess.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/create_monocle_default.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create monocle object — create_monocle_default","text":"","code":"if (FALSE) { # \\dontrun{ set.seed(2024) # create an already-transposed artificial expression matrix expr_matrix <- matrix(     c(runif(20 * 10), runif(30 * 10, min = 3, max = 4)),     nrow = 10, byrow = FALSE ) colnames(expr_matrix) <- as.character(seq_len(ncol(expr_matrix))) rownames(expr_matrix) <- paste(\"feature\", seq_len(nrow(expr_matrix)))  # uncomment to create the monocle object mon_obj <- create_monocle_default(     normalized_expression_matrix = expr_matrix,     pca_emb = NULL,     umap_emb = NULL,     metadata_df = NULL ) } # }"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/create_monocle_from_clustassess.html","id":null,"dir":"Reference","previous_headings":"","what":"Create monocle object from a ClustAssess object — create_monocle_from_clustassess","title":"Create monocle object from a ClustAssess object — create_monocle_from_clustassess","text":"Use object generated using ClustAssess automatic_stability_assessment function create Monocle object stable number clusters.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/create_monocle_from_clustassess.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create monocle object from a ClustAssess object — create_monocle_from_clustassess","text":"","code":"create_monocle_from_clustassess(   normalized_expression_matrix,   count_matrix = NULL,   clustassess_object,   metadata_df,   stable_feature_type,   stable_feature_set_size,   stable_clustering_method,   stable_n_clusters = NULL,   use_all_genes = FALSE )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/create_monocle_from_clustassess.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create monocle object from a ClustAssess object — create_monocle_from_clustassess","text":"normalized_expression_matrix normalized expression matrix genes rows cells columns. count_matrix count matrix genes rows cells columns. NULL, normalized_expression_matrix used. clustassess_object output automatic_stability_assessment. metadata_df metadata dataframe cell names rownames. NULL, dataframe single column named identical_ident created. stable_feature_type feature type leads stable clusters. stable_feature_set_size feature size leads stable clusters. stable_clustering_method clustering method leads stable clusters. stable_n_clusters number clusters stable. NULL, clusters provided. Defaults NULL. use_all_genes boolean value indicating expression matrix truncated genes used stability assessment. Defaults FALSE.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/create_monocle_from_clustassess.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create monocle object from a ClustAssess object — create_monocle_from_clustassess","text":"Monocle object expression matrix, stable number clusters identified ClustAssess.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/create_monocle_from_clustassess.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create monocle object from a ClustAssess object — create_monocle_from_clustassess","text":"","code":"if (FALSE) { # \\dontrun{ set.seed(2024) # create an already-transposed artificial expression matrix expr_matrix <- matrix(     c(runif(20 * 10), runif(30 * 10, min = 3, max = 4)),     nrow = 10, byrow = FALSE ) colnames(expr_matrix) <- as.character(seq_len(ncol(expr_matrix))) rownames(expr_matrix) <- paste(\"feature\", seq_len(nrow(expr_matrix)))  autom_object <- automatic_stability_assessment(     expression_matrix = expr_matrix,     n_repetitions = 3,     n_neigh_sequence = c(5),     resolution_sequence = c(0.1, 0.5),     features_sets = list(         \"set1\" = rownames(expr_matrix)     ),     steps = list(         \"set1\" = c(5, 7)     ),     umap_arguments = list(         # the following parameters have been modified         # from the default values to ensure that the function         # will run under 5 seconds         n_neighbors = 3,         approx_pow = TRUE,         n_epochs = 0,         init = \"random\",         min_dist = 0.3     ),     n_top_configs = 1,     algorithms_clustering_assessment = 1,     save_temp = FALSE,     verbose = FALSE )   # uncomment to create the monocle object # mon_obj <- create_monocle_from_clustassess( #     normalized_expression_matrix = expr_matrix, #     clustassess_object = autom_object, #     metadata = NULL, #     stable_feature_type = \"set1\", #     stable_feature_set_size = \"5\", #     stable_clustering_method = \"Louvain\" # ) } # }"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/create_monocle_from_clustassess_app.html","id":null,"dir":"Reference","previous_headings":"","what":"Create monocle object from a ClustAssess shiny app — create_monocle_from_clustassess_app","title":"Create monocle object from a ClustAssess shiny app — create_monocle_from_clustassess_app","text":"Use files generated ClustAssess app create Monocle object stable number clusters.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/create_monocle_from_clustassess_app.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create monocle object from a ClustAssess shiny app — create_monocle_from_clustassess_app","text":"","code":"create_monocle_from_clustassess_app(   app_folder,   stable_feature_type,   stable_feature_set_size,   stable_clustering_method,   stable_n_clusters = NULL,   use_all_genes = FALSE )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/create_monocle_from_clustassess_app.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create monocle object from a ClustAssess shiny app — create_monocle_from_clustassess_app","text":"app_folder Path pointing folder containing ClustAssess app. stable_feature_type feature type leads stable clusters. stable_feature_set_size feature size leads stable clusters. stable_clustering_method clustering method leads stable clusters. stable_n_clusters number clusters stable. NULL, clusters provided. Defaults NULL. use_all_genes boolean value indicating expression matrix truncated genes used stability assessment. Defaults FALSE.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/create_monocle_from_clustassess_app.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create monocle object from a ClustAssess shiny app — create_monocle_from_clustassess_app","text":"Monocle object expression matrix, stable number clusters identified ClustAssess.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/create_seurat_object_default.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Seurat object — create_seurat_object_default","title":"Create Seurat object — create_seurat_object_default","text":"Use normalized expression matrix , potentially, already generated PCA / UMAP embedding, create Seurat object.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/create_seurat_object_default.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Seurat object — create_seurat_object_default","text":"","code":"create_seurat_object_default(   normalized_expression_matrix,   count_matrix = NULL,   pca_embedding = NULL,   umap_embedding = NULL,   metadata_df = NULL )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/create_seurat_object_default.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Seurat object — create_seurat_object_default","text":"normalized_expression_matrix normalized expression matrix genes rows cells columns. count_matrix count matrix genes rows cells columns. NULL, normalized_expression_matrix used. pca_embedding PCA embedding expression matrix. NULL, pca created using Seurat package (default parameters). umap_embedding UMAP embedding expression matrix. NULL, umap created using Seurat package (default parameters). metadata_df metadata dataframe cell names rownames. NULL, dataframe single column named identical_ident created.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/create_seurat_object_default.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Seurat object — create_seurat_object_default","text":"Seurat object expression matrix, stable number clusters identified ClustAssess.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/create_seurat_object_from_clustassess_app.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Seurat object from a ClustAssess shiny app — create_seurat_object_from_clustassess_app","title":"Create Seurat object from a ClustAssess shiny app — create_seurat_object_from_clustassess_app","text":"Use files generated ClustAssess app create Seurat object stable number clusters.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/create_seurat_object_from_clustassess_app.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Seurat object from a ClustAssess shiny app — create_seurat_object_from_clustassess_app","text":"","code":"create_seurat_object_from_clustassess_app(   app_folder,   stable_feature_type,   stable_feature_set_size,   stable_clustering_method,   stable_n_clusters = NULL,   use_all_genes = FALSE )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/create_seurat_object_from_clustassess_app.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Seurat object from a ClustAssess shiny app — create_seurat_object_from_clustassess_app","text":"app_folder Path pointing folder containing ClustAssess app. stable_feature_type feature type leads stable clusters. stable_feature_set_size feature size leads stable clusters. stable_clustering_method clustering method leads stable clusters. stable_n_clusters number clusters stable. NULL, clusters provided. Defaults NULL. use_all_genes boolean value indicating expression matrix truncated genes used stability assessment. Defaults FALSE.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/create_seurat_object_from_clustassess_app.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Seurat object from a ClustAssess shiny app — create_seurat_object_from_clustassess_app","text":"Seurat object expression matrix, stable number clusters identified ClustAssess.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/element_agreement.html","id":null,"dir":"Reference","previous_headings":"","what":"Element-Wise Average Agreement Between a Set of Clusterings — element_agreement","title":"Element-Wise Average Agreement Between a Set of Clusterings — element_agreement","text":"Inspect consistently set clusterings agree reference clustering calculating element-wise average agreement.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/element_agreement.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Element-Wise Average Agreement Between a Set of Clusterings — element_agreement","text":"","code":"element_agreement(   reference_clustering,   clustering_list,   alpha = 0.9,   r = 1,   rescale_path_type = \"max\",   ppr_implementation = \"prpack\",   dist_rescaled = FALSE,   row_normalize = TRUE )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/element_agreement.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Element-Wise Average Agreement Between a Set of Clusterings — element_agreement","text":"reference_clustering reference clustering, clustering clustering_list compared . can either: numeric/character/factor vector cluster labels element. samples x clusters matrix/Matrix::Matrix nonzero membership values. hclust object. clustering_list list clustering results, either: numeric/character/factor vector cluster labels element. samples x clusters matrix/Matrix::Matrix nonzero membership values. hclust object. alpha numeric giving personalized PageRank damping factor; 1 - alpha restart probability PPR random walk. r numeric hierarchical scaling parameter. rescale_path_type string; rescale hierarchical height : \"max\" : maximum path root. \"min\" : minimum path form root. \"linkage\" : use linkage distances clustering. ppr_implementation Choose implementation personalized page-rank calculation: \"prpack\": use PPR algorithms igraph. \"power_iteration\": use power_iteration method. dist_rescaled logical: TRUE, linkage distances linearly rescaled -0 1. row_normalize Whether normalize rows clustering_result sum one calculating ECS. recommended set TRUE, lead slightly different ECS values compared clusim.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/element_agreement.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Element-Wise Average Agreement Between a Set of Clusterings — element_agreement","text":"vector containing element-wise average agreement.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/element_agreement.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Element-Wise Average Agreement Between a Set of Clusterings — element_agreement","text":"Gates, . J., Wood, . B., Hetrick, W. P., & Ahn, Y. Y. (2019). Element-centric clustering comparison unifies overlaps hierarchy. Scientific reports, 9(1), 1-13. https://doi.org/10.1038/s41598-019-44892-y","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/element_agreement.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Element-Wise Average Agreement Between a Set of Clusterings — element_agreement","text":"","code":"# perform k-means clustering across 20 random seeds reference.clustering <- iris$Species clustering.list <- lapply(1:20, function(x) kmeans(iris[, 1:4], centers = 3)$cluster) element_agreement(reference.clustering, clustering.list) #>   [1] 0.8980000 0.8020000 0.8020000 0.8020000 0.8980000 0.8980000 0.8980000 #>   [8] 0.8980000 0.8020000 0.8020000 0.8980000 0.8980000 0.8020000 0.8020000 #>  [15] 0.8980000 0.8980000 0.8980000 0.8980000 0.8980000 0.8980000 0.8980000 #>  [22] 0.8980000 0.8980000 0.8980000 0.8020000 0.8020000 0.8980000 0.8980000 #>  [29] 0.8980000 0.8020000 0.8020000 0.8980000 0.8980000 0.8980000 0.8020000 #>  [36] 0.8980000 0.8980000 0.8980000 0.8020000 0.8980000 0.8980000 0.8020000 #>  [43] 0.8020000 0.8980000 0.8980000 0.8020000 0.8980000 0.8020000 0.8980000 #>  [50] 0.8980000 0.6856855 0.6856855 0.1717500 0.6856855 0.6856855 0.6856855 #>  [57] 0.6856855 0.5659355 0.6856855 0.6856855 0.5659355 0.6856855 0.6856855 #>  [64] 0.6856855 0.6856855 0.6856855 0.6856855 0.6856855 0.6856855 0.6856855 #>  [71] 0.6856855 0.6856855 0.6856855 0.6856855 0.6856855 0.6856855 0.6856855 #>  [78] 0.1717500 0.6856855 0.6856855 0.6856855 0.6856855 0.6856855 0.6856855 #>  [85] 0.6856855 0.6856855 0.6856855 0.6856855 0.6856855 0.6856855 0.6856855 #>  [92] 0.6856855 0.6856855 0.5659355 0.6856855 0.6856855 0.6856855 0.6856855 #>  [99] 0.5659355 0.6856855 0.6602500 0.3143145 0.6602500 0.6602500 0.6602500 #> [106] 0.6602500 0.3143145 0.6602500 0.6602500 0.6602500 0.6602500 0.6602500 #> [113] 0.6602500 0.3143145 0.3143145 0.6602500 0.6602500 0.6602500 0.6602500 #> [120] 0.3143145 0.6602500 0.3143145 0.6602500 0.3143145 0.6602500 0.6602500 #> [127] 0.3143145 0.3143145 0.6602500 0.6602500 0.6602500 0.6602500 0.6602500 #> [134] 0.3143145 0.6602500 0.6602500 0.6602500 0.6602500 0.3143145 0.6602500 #> [141] 0.6602500 0.6602500 0.3143145 0.6602500 0.6602500 0.6602500 0.3143145 #> [148] 0.6602500 0.6602500 0.3143145"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/element_consistency.html","id":null,"dir":"Reference","previous_headings":"","what":"Element-Wise Consistency Between a Set of Clusterings — element_consistency","title":"Element-Wise Consistency Between a Set of Clusterings — element_consistency","text":"Inspect consistency set clusterings calculating element-wise clustering consistency (also known element-wise frustration).","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/element_consistency.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Element-Wise Consistency Between a Set of Clusterings — element_consistency","text":"","code":"element_consistency(   clustering_list,   alpha = 0.9,   r = 1,   rescale_path_type = \"max\",   ppr_implementation = \"prpack\",   dist_rescaled = FALSE,   row_normalize = TRUE )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/element_consistency.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Element-Wise Consistency Between a Set of Clusterings — element_consistency","text":"clustering_list list clustering results, either: numeric/character/factor vector cluster labels element. samples x clusters matrix/Matrix::Matrix nonzero membership values. hclust object. alpha numeric giving personalized PageRank damping factor; 1 - alpha restart probability PPR random walk. r numeric hierarchical scaling parameter. rescale_path_type string; rescale hierarchical height : \"max\" : maximum path root. \"min\" : minimum path form root. \"linkage\" : use linkage distances clustering. ppr_implementation Choose implementation personalized page-rank calculation: \"prpack\": use PPR algorithms igraph. \"power_iteration\": use power_iteration method. dist_rescaled logical: TRUE, linkage distances linearly rescaled -0 1. row_normalize Whether normalize rows clustering_result sum one calculating ECS. recommended set TRUE, lead slightly different ECS values compared clusim.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/element_consistency.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Element-Wise Consistency Between a Set of Clusterings — element_consistency","text":"vector containing element-wise consistency. calculate_sim_matrix set TRUE, element similarity matrix returned well.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/element_consistency.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Element-Wise Consistency Between a Set of Clusterings — element_consistency","text":"Gates, . J., Wood, . B., Hetrick, W. P., & Ahn, Y. Y. (2019). Element-centric clustering comparison unifies overlaps hierarchy. Scientific reports, 9(1), 1-13. https://doi.org/10.1038/s41598-019-44892-y","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/element_consistency.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Element-Wise Consistency Between a Set of Clusterings — element_consistency","text":"","code":"# cluster across 20 random seeds clustering.list <- lapply(1:20, function(x) kmeans(mtcars, centers = 3)$cluster) element_consistency(clustering.list) #>           Mazda RX4       Mazda RX4 Wag          Datsun 710      Hornet 4 Drive  #>           0.7192531           0.7192531           0.8587655           0.5922761  #>   Hornet Sportabout             Valiant          Duster 360           Merc 240D  #>           0.7402256           0.5071650           0.7402256           0.8587655  #>            Merc 230            Merc 280           Merc 280C          Merc 450SE  #>           0.8587655           0.7192531           0.7192531           0.6785714  #>          Merc 450SL         Merc 450SLC  Cadillac Fleetwood Lincoln Continental  #>           0.6785714           0.6785714           0.6927736           0.6927736  #>   Chrysler Imperial            Fiat 128         Honda Civic      Toyota Corolla  #>           0.6927736           0.8587655           0.8587655           0.8587655  #>       Toyota Corona    Dodge Challenger         AMC Javelin          Camaro Z28  #>           0.8587655           0.6785714           0.6785714           0.7402256  #>    Pontiac Firebird           Fiat X1-9       Porsche 914-2        Lotus Europa  #>           0.6927736           0.8587655           0.8587655           0.8587655  #>      Ford Pantera L        Ferrari Dino       Maserati Bora          Volvo 142E  #>           0.7402256           0.7192531           0.7402256           0.8587655"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/element_sim.html","id":null,"dir":"Reference","previous_headings":"","what":"The Element-Centric Clustering Similarity — element_sim","title":"The Element-Centric Clustering Similarity — element_sim","text":"Calculates average element-centric similarity two clustering results","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/element_sim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Element-Centric Clustering Similarity — element_sim","text":"","code":"element_sim(   clustering1,   clustering2,   alpha = 0.9,   r_cl1 = 1,   rescale_path_type_cl1 = \"max\",   ppr_implementation_cl1 = \"prpack\",   dist_rescaled_cl1 = FALSE,   row_normalize_cl1 = TRUE,   r_cl2 = 1,   rescale_path_type_cl2 = \"max\",   ppr_implementation_cl2 = \"prpack\",   dist_rescaled_cl2 = FALSE,   row_normalize_cl2 = TRUE )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/element_sim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Element-Centric Clustering Similarity — element_sim","text":"clustering1 first clustering result, can one : numeric/character/factor vector cluster labels element. samples x clusters matrix/Matrix::Matrix nonzero membership values. hclust object. clustering2 second clustering result, can one : numeric/character/factor vector cluster labels element. samples x clusters matrix/Matrix::Matrix nonzero membership values. hclust object. alpha numeric giving personalized PageRank damping factor; 1 - alpha restart probability PPR random walk. r_cl1 numeric hierarchical scaling parameter first clustering. rescale_path_type_cl1 string; rescale hierarchical height first clustering : \"max\" : maximum path root. \"min\" : minimum path form root. \"linkage\" : use linkage distances clustering. ppr_implementation_cl1 Choose implementation personalized page-rank calculation first clustering: \"prpack\": use PPR algorithms igraph. \"power_iteration\": use power_iteration method. dist_rescaled_cl1 logical: TRUE, linkage distances first clustering linearly rescaled -0 1. row_normalize_cl1 Whether normalize rows first clustering sum one calculating ECS. recommended set TRUE, lead slightly different ECS values compared clusim. r_cl2 numeric hierarchical scaling parameter second clustering. rescale_path_type_cl2 string; rescale hierarchical height second clustering : \"max\" : maximum path root. \"min\" : minimum path form root. \"linkage\" : use linkage distances clustering. ppr_implementation_cl2 Choose implementation personalized page-rank calculation second clustering: \"prpack\": use PPR algorithms igraph. \"power_iteration\": use power_iteration method. dist_rescaled_cl2 logical: TRUE, linkage distances second clustering linearly rescaled -0 1. row_normalize_cl2 Whether normalize rows second clustering sum one calculating ECS. recommended set TRUE, lead slightly different ECS values compared clusim.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/element_sim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The Element-Centric Clustering Similarity — element_sim","text":"average element-wise similarity two Clusterings.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/element_sim.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Element-Centric Clustering Similarity — element_sim","text":"","code":"km.res <- kmeans(mtcars, centers = 3)$cluster hc.res <- hclust(dist(mtcars)) element_sim(km.res, hc.res) #> [1] 0.4444444"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/element_sim_elscore.html","id":null,"dir":"Reference","previous_headings":"","what":"The Element-Centric Clustering Similarity for each Element — element_sim_elscore","title":"The Element-Centric Clustering Similarity for each Element — element_sim_elscore","text":"Calculates element-wise element-centric similarity two clustering results.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/element_sim_elscore.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Element-Centric Clustering Similarity for each Element — element_sim_elscore","text":"","code":"element_sim_elscore(   clustering1,   clustering2,   alpha = 0.9,   r_cl1 = 1,   rescale_path_type_cl1 = \"max\",   ppr_implementation_cl1 = \"prpack\",   dist_rescaled_cl1 = FALSE,   row_normalize_cl1 = TRUE,   r_cl2 = 1,   rescale_path_type_cl2 = \"max\",   ppr_implementation_cl2 = \"prpack\",   dist_rescaled_cl2 = FALSE,   row_normalize_cl2 = TRUE )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/element_sim_elscore.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Element-Centric Clustering Similarity for each Element — element_sim_elscore","text":"clustering1 first clustering result, can one : numeric/character/factor vector cluster labels element. samples x clusters matrix/Matrix::Matrix nonzero membership values. hclust object. clustering2 second clustering result, can one : numeric/character/factor vector cluster labels element. samples x clusters matrix/Matrix::Matrix nonzero membership values. hclust object. alpha numeric giving personalized PageRank damping factor; 1 - alpha restart probability PPR random walk. r_cl1 numeric hierarchical scaling parameter first clustering. rescale_path_type_cl1 string; rescale hierarchical height first clustering : \"max\" : maximum path root. \"min\" : minimum path form root. \"linkage\" : use linkage distances clustering. ppr_implementation_cl1 Choose implementation personalized page-rank calculation first clustering: \"prpack\": use PPR algorithms igraph. \"power_iteration\": use power_iteration method. dist_rescaled_cl1 logical: TRUE, linkage distances first clustering linearly rescaled -0 1. row_normalize_cl1 Whether normalize rows first clustering sum one calculating ECS. recommended set TRUE, lead slightly different ECS values compared clusim. r_cl2 numeric hierarchical scaling parameter second clustering. rescale_path_type_cl2 string; rescale hierarchical height second clustering : \"max\" : maximum path root. \"min\" : minimum path form root. \"linkage\" : use linkage distances clustering. ppr_implementation_cl2 Choose implementation personalized page-rank calculation second clustering: \"prpack\": use PPR algorithms igraph. \"power_iteration\": use power_iteration method. dist_rescaled_cl2 logical: TRUE, linkage distances second clustering linearly rescaled -0 1. row_normalize_cl2 Whether normalize rows second clustering sum one calculating ECS. recommended set TRUE, lead slightly different ECS values compared clusim.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/element_sim_elscore.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The Element-Centric Clustering Similarity for each Element — element_sim_elscore","text":"Vector element-centric similarity two clusterings element.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/element_sim_elscore.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"The Element-Centric Clustering Similarity for each Element — element_sim_elscore","text":"Gates, . J., Wood, . B., Hetrick, W. P., & Ahn, Y. Y. (2019). Element-centric clustering comparison unifies overlaps hierarchy. Scientific reports, 9(1), 1-13. https://doi.org/10.1038/s41598-019-44892-y","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/element_sim_elscore.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Element-Centric Clustering Similarity for each Element — element_sim_elscore","text":"","code":"km.res <- kmeans(iris[, 1:4], centers = 8)$cluster hc.res <- hclust(dist(iris[, 1:4])) element_sim_elscore(km.res, hc.res) #>          1          2          3          4          5          6          7  #> 0.35970732 0.28463113 0.27504654 0.28629676 0.34023494 0.14877225 0.24578347  #>          8          9         10         11         12         13         14  #> 0.35414515 0.26102546 0.28463113 0.37292373 0.18140078 0.27187915 0.24565854  #>         15         16         17         18         19         20         21  #> 0.20410258 0.20410258 0.20482698 0.35970732 0.14877225 0.37418879 0.37070483  #>         22         23         24         25         26         27         28  #> 0.37418879 0.20140004 0.36563267 0.18140078 0.27187915 0.36563267 0.35031846  #>         29         30         31         32         33         34         35  #> 0.35031846 0.25489307 0.25489307 0.37070483 0.22568160 0.22568160 0.28463113  #>         36         37         38         39         40         41         42  #> 0.20413084 0.37632204 0.34023494 0.26102546 0.35414515 0.35993563 0.06290065  #>         43         44         45         46         47         48         49  #> 0.26172270 0.36711590 0.36987484 0.28463113 0.37793070 0.28629676 0.37292373  #>         50         51         52         53         54         55         56  #> 0.19109146 0.56158716 0.56950919 0.56158716 0.51263990 0.56290102 0.50763058  #>         57         58         59         60         61         62         63  #> 0.56950919 0.39088001 0.56290102 0.52643208 0.41153617 0.51868674 0.49906433  #>         64         65         66         67         68         69         70  #> 0.55523802 0.51409810 0.57095737 0.50763058 0.53340573 0.54022294 0.51294180  #>         71         72         73         74         75         76         77  #> 0.55275532 0.51868674 0.54271092 0.57003772 0.57014260 0.57095737 0.57086373  #>         78         79         80         81         82         83         84  #> 0.58021144 0.56221674 0.51409810 0.50674233 0.50674233 0.52168669 0.53530182  #>         85         86         87         88         89         90         91  #> 0.50763058 0.57896174 0.57013180 0.54022294 0.52689686 0.51263990 0.50763058  #>         92         93         94         95         96         97         98  #> 0.55523802 0.52168669 0.39088001 0.52938883 0.52041953 0.52041953 0.57014260  #>         99        100        101        102        103        104        105  #> 0.40000525 0.52938883 0.32101651 0.53373774 0.37552633 0.42059736 0.31830150  #>        106        107        108        109        110        111        112  #> 0.38418459 0.43395801 0.37600855 0.31146160 0.38881815 0.42625089 0.55256576  #>        113        114        115        116        117        118        119  #> 0.32523715 0.54150766 0.56413558 0.43446073 0.41378213 0.38881815 0.39272284  #>        120        121        122        123        124        125        126  #> 0.55356905 0.33853655 0.55087880 0.38418459 0.54279062 0.34649405 0.36750946  #>        127        128        129        130        131        132        133  #> 0.54279062 0.54321087 0.31112970 0.36750946 0.37600855 0.38881815 0.31112970  #>        134        135        136        137        138        139        140  #> 0.53530182 0.57093378 0.38881815 0.30853205 0.41378213 0.54321087 0.32523715  #>        141        142        143        144        145        146        147  #> 0.34166244 0.32523715 0.53373774 0.33853655 0.34166244 0.32523715 0.55256576  #>        148        149        150  #> 0.42625089 0.40329848 0.56442420"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/element_sim_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Pairwise Comparison of Clusterings — element_sim_matrix","title":"Pairwise Comparison of Clusterings — element_sim_matrix","text":"Compare set clusterings calculating pairwise average element-centric clustering similarities.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/element_sim_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pairwise Comparison of Clusterings — element_sim_matrix","text":"","code":"element_sim_matrix(   clustering_list,   output_type = \"matrix\",   alpha = 0.9,   r = 1,   rescale_path_type = \"max\",   ppr_implementation = \"prpack\",   dist_rescaled = FALSE,   row_normalize = TRUE )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/element_sim_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pairwise Comparison of Clusterings — element_sim_matrix","text":"clustering_list list clustering results, either: numeric/character/factor vector cluster labels element. samples x clusters matrix/Matrix::Matrix nonzero membership values. hclust object. output_type string specifying whether output matrix data.frame. alpha numeric giving personalized PageRank damping factor; 1 - alpha restart probability PPR random walk. r numeric hierarchical scaling parameter. rescale_path_type string; rescale hierarchical height : \"max\" : maximum path root. \"min\" : minimum path form root. \"linkage\" : use linkage distances clustering. ppr_implementation Choose implementation personalized page-rank calculation: \"prpack\": use PPR algorithms igraph. \"power_iteration\": use power_iteration method. dist_rescaled logical: TRUE, linkage distances linearly rescaled -0 1. row_normalize Whether normalize rows clustering_result sum one calculating ECS. recommended set TRUE, lead slightly different ECS values compared clusim.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/element_sim_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pairwise Comparison of Clusterings — element_sim_matrix","text":"matrix data.frame containing pairwise ECS values.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/element_sim_matrix.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Pairwise Comparison of Clusterings — element_sim_matrix","text":"Gates, . J., Wood, . B., Hetrick, W. P., & Ahn, Y. Y. (2019). Element-centric clustering comparison unifies overlaps hierarchy. Scientific reports, 9(1), 1-13. https://doi.org/10.1038/s41598-019-44892-y","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/element_sim_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pairwise Comparison of Clusterings — element_sim_matrix","text":"","code":"# cluster across 20 random seeds clustering.list <- lapply(1:20, function(x) kmeans(mtcars, centers = 3)$cluster) element_sim_matrix(clustering.list, output_type = \"matrix\") #>            [,1]      [,2]      [,3]      [,4]      [,5]      [,6]      [,7] #>  [1,] 1.0000000 0.5396205 0.5396205 1.0000000 0.5396205 1.0000000 1.0000000 #>  [2,] 0.5396205 1.0000000 1.0000000 0.5396205 1.0000000 0.5396205 0.5396205 #>  [3,] 0.5396205 1.0000000 1.0000000 0.5396205 1.0000000 0.5396205 0.5396205 #>  [4,] 1.0000000 0.5396205 0.5396205 1.0000000 0.5396205 1.0000000 1.0000000 #>  [5,] 0.5396205 1.0000000 1.0000000 0.5396205 1.0000000 0.5396205 0.5396205 #>  [6,] 1.0000000 0.5396205 0.5396205 1.0000000 0.5396205 1.0000000 1.0000000 #>  [7,] 1.0000000 0.5396205 0.5396205 1.0000000 0.5396205 1.0000000 1.0000000 #>  [8,] 1.0000000 0.5396205 0.5396205 1.0000000 0.5396205 1.0000000 1.0000000 #>  [9,] 0.5503724 0.7012775 0.7012775 0.5503724 0.7012775 0.5503724 0.5503724 #> [10,] 0.5503724 0.7012775 0.7012775 0.5503724 0.7012775 0.5503724 0.5503724 #> [11,] 0.5503724 0.7012775 0.7012775 0.5503724 0.7012775 0.5503724 0.5503724 #> [12,] 0.5396205 1.0000000 1.0000000 0.5396205 1.0000000 0.5396205 0.5396205 #> [13,] 0.5396205 1.0000000 1.0000000 0.5396205 1.0000000 0.5396205 0.5396205 #> [14,] 0.5503724 0.7012775 0.7012775 0.5503724 0.7012775 0.5503724 0.5503724 #> [15,] 0.5396205 1.0000000 1.0000000 0.5396205 1.0000000 0.5396205 0.5396205 #> [16,] 1.0000000 0.5396205 0.5396205 1.0000000 0.5396205 1.0000000 1.0000000 #> [17,] 1.0000000 0.5396205 0.5396205 1.0000000 0.5396205 1.0000000 1.0000000 #> [18,] 0.5396205 1.0000000 1.0000000 0.5396205 1.0000000 0.5396205 0.5396205 #> [19,] 0.5503724 0.7012775 0.7012775 0.5503724 0.7012775 0.5503724 0.5503724 #> [20,] 1.0000000 0.5396205 0.5396205 1.0000000 0.5396205 1.0000000 1.0000000 #>            [,8]      [,9]     [,10]     [,11]     [,12]     [,13]     [,14] #>  [1,] 1.0000000 0.5503724 0.5503724 0.5503724 0.5396205 0.5396205 0.5503724 #>  [2,] 0.5396205 0.7012775 0.7012775 0.7012775 1.0000000 1.0000000 0.7012775 #>  [3,] 0.5396205 0.7012775 0.7012775 0.7012775 1.0000000 1.0000000 0.7012775 #>  [4,] 1.0000000 0.5503724 0.5503724 0.5503724 0.5396205 0.5396205 0.5503724 #>  [5,] 0.5396205 0.7012775 0.7012775 0.7012775 1.0000000 1.0000000 0.7012775 #>  [6,] 1.0000000 0.5503724 0.5503724 0.5503724 0.5396205 0.5396205 0.5503724 #>  [7,] 1.0000000 0.5503724 0.5503724 0.5503724 0.5396205 0.5396205 0.5503724 #>  [8,] 1.0000000 0.5503724 0.5503724 0.5503724 0.5396205 0.5396205 0.5503724 #>  [9,] 0.5503724 1.0000000 1.0000000 1.0000000 0.7012775 0.7012775 1.0000000 #> [10,] 0.5503724 1.0000000 1.0000000 1.0000000 0.7012775 0.7012775 1.0000000 #> [11,] 0.5503724 1.0000000 1.0000000 1.0000000 0.7012775 0.7012775 1.0000000 #> [12,] 0.5396205 0.7012775 0.7012775 0.7012775 1.0000000 1.0000000 0.7012775 #> [13,] 0.5396205 0.7012775 0.7012775 0.7012775 1.0000000 1.0000000 0.7012775 #> [14,] 0.5503724 1.0000000 1.0000000 1.0000000 0.7012775 0.7012775 1.0000000 #> [15,] 0.5396205 0.7012775 0.7012775 0.7012775 1.0000000 1.0000000 0.7012775 #> [16,] 1.0000000 0.5503724 0.5503724 0.5503724 0.5396205 0.5396205 0.5503724 #> [17,] 1.0000000 0.5503724 0.5503724 0.5503724 0.5396205 0.5396205 0.5503724 #> [18,] 0.5396205 0.7012775 0.7012775 0.7012775 1.0000000 1.0000000 0.7012775 #> [19,] 0.5503724 1.0000000 1.0000000 1.0000000 0.7012775 0.7012775 1.0000000 #> [20,] 1.0000000 0.5503724 0.5503724 0.5503724 0.5396205 0.5396205 0.5503724 #>           [,15]     [,16]     [,17]     [,18]     [,19]     [,20] #>  [1,] 0.5396205 1.0000000 1.0000000 0.5396205 0.5503724 1.0000000 #>  [2,] 1.0000000 0.5396205 0.5396205 1.0000000 0.7012775 0.5396205 #>  [3,] 1.0000000 0.5396205 0.5396205 1.0000000 0.7012775 0.5396205 #>  [4,] 0.5396205 1.0000000 1.0000000 0.5396205 0.5503724 1.0000000 #>  [5,] 1.0000000 0.5396205 0.5396205 1.0000000 0.7012775 0.5396205 #>  [6,] 0.5396205 1.0000000 1.0000000 0.5396205 0.5503724 1.0000000 #>  [7,] 0.5396205 1.0000000 1.0000000 0.5396205 0.5503724 1.0000000 #>  [8,] 0.5396205 1.0000000 1.0000000 0.5396205 0.5503724 1.0000000 #>  [9,] 0.7012775 0.5503724 0.5503724 0.7012775 1.0000000 0.5503724 #> [10,] 0.7012775 0.5503724 0.5503724 0.7012775 1.0000000 0.5503724 #> [11,] 0.7012775 0.5503724 0.5503724 0.7012775 1.0000000 0.5503724 #> [12,] 1.0000000 0.5396205 0.5396205 1.0000000 0.7012775 0.5396205 #> [13,] 1.0000000 0.5396205 0.5396205 1.0000000 0.7012775 0.5396205 #> [14,] 0.7012775 0.5503724 0.5503724 0.7012775 1.0000000 0.5503724 #> [15,] 1.0000000 0.5396205 0.5396205 1.0000000 0.7012775 0.5396205 #> [16,] 0.5396205 1.0000000 1.0000000 0.5396205 0.5503724 1.0000000 #> [17,] 0.5396205 1.0000000 1.0000000 0.5396205 0.5503724 1.0000000 #> [18,] 1.0000000 0.5396205 0.5396205 1.0000000 0.7012775 0.5396205 #> [19,] 0.7012775 0.5503724 0.5503724 0.7012775 1.0000000 0.5503724 #> [20,] 0.5396205 1.0000000 1.0000000 0.5396205 0.5503724 1.0000000"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/getNNmatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Computes the NN adjacency matrix given the neighbours — getNNmatrix","title":"Computes the NN adjacency matrix given the neighbours — getNNmatrix","text":"Computes NN adjacency matrix given neighbours","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/getNNmatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computes the NN adjacency matrix given the neighbours — getNNmatrix","text":"","code":"getNNmatrix(nnRanked, k = -1L, start = 0L, prune = 0)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/getNNmatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computes the NN adjacency matrix given the neighbours — getNNmatrix","text":"nnRanked matrix lists nearest neighbours point k number neighbours consider. Defaults -1, means neighbours. start index first neighbour consider. Defaults 0. prune threshold prune SNN matrix. -1, function return NN matrix. Defaults 0.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/getNNmatrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Computes the NN adjacency matrix given the neighbours — getNNmatrix","text":"list NN SNN adjacency matrices.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/get_clusters_from_clustassess_object.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract config-specific clusters from a ClustAssess object — get_clusters_from_clustassess_object","title":"Extract config-specific clusters from a ClustAssess object — get_clusters_from_clustassess_object","text":"Given output automatic_stability_assessment function, extract clusters specific particular configuration feature type, feature size, clustering method , optionally, number clusters.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/get_clusters_from_clustassess_object.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract config-specific clusters from a ClustAssess object — get_clusters_from_clustassess_object","text":"","code":"get_clusters_from_clustassess_object(   clustassess_object,   feature_type = NULL,   feature_size = NULL,   clustering_method = NULL,   nclusters = NULL )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/get_clusters_from_clustassess_object.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract config-specific clusters from a ClustAssess object — get_clusters_from_clustassess_object","text":"clustassess_object Output automatic_stability_assessment. feature_type Type feature used dimensionality reduction. NULL, select first available feature. feature_size Size feature set used clustering. NULL, select first available feature size. clustering_method Clustering method used. NULL, select first available clustering method. nclusters Number clusters extract. NULL, clusters returned.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/get_clusters_from_clustassess_object.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract config-specific clusters from a ClustAssess object — get_clusters_from_clustassess_object","text":"list clusters specific given configuration. number cluster contain list partitions specific k ECC value indicating overall stability k.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/get_highest_prune_param.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the highest pruning parameter for the SNN graph given NN matrix — get_highest_prune_param","title":"Calculate the highest pruning parameter for the SNN graph given NN matrix — get_highest_prune_param","text":"Given NN adjacency matrix, function calculates highest pruning parameter SNN graph preserves connectivity graph.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/get_highest_prune_param.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the highest pruning parameter for the SNN graph given NN matrix — get_highest_prune_param","text":"","code":"get_highest_prune_param(nn_matrix, n_neigh)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/get_highest_prune_param.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the highest pruning parameter for the SNN graph given NN matrix — get_highest_prune_param","text":"nn_matrix adjacency matrix nearest neighbour graph. n_neigh number nearest neighbours.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/get_highest_prune_param.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the highest pruning parameter for the SNN graph given NN matrix — get_highest_prune_param","text":"list following fields: prune_value: value highest pruning parameter. adj_matrix: adjacency matrix SNN graph pruning.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/get_highest_prune_param.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Calculate the highest pruning parameter for the SNN graph given NN matrix — get_highest_prune_param","text":"Given way SNN graph built, possible values pruning parameter limited can determined formula / (2 * n_neigh - ), number nearest neighbours 0 n_neigh.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/get_highest_prune_param.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the highest pruning parameter for the SNN graph given NN matrix — get_highest_prune_param","text":"","code":"set.seed(2024) # create an artificial pca embedding pca_embedding <- matrix(     c(runif(100 * 10), runif(100 * 10, min = 3, max = 4)),     nrow = 200, byrow = TRUE ) rownames(pca_embedding) <- as.character(1:200) colnames(pca_embedding) <- paste(\"PC\", 1:10)  # calculate the nn adjacency matrix nn_matrix <- getNNmatrix(     RANN::nn2(pca_embedding, k = 5)$nn.idx,     5,     0,     -1 )$nn  get_highest_prune_param(nn_matrix, 5)$prune_value #> [1] 0"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/get_highest_prune_param_embedding.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the highest pruning parameter for the SNN graph given Embedding — get_highest_prune_param_embedding","title":"Calculate the highest pruning parameter for the SNN graph given Embedding — get_highest_prune_param_embedding","text":"Given embedding, function calculates highest pruning parameter SNN graph preserves connectivity graph.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/get_highest_prune_param_embedding.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the highest pruning parameter for the SNN graph given Embedding — get_highest_prune_param_embedding","text":"","code":"get_highest_prune_param_embedding(embedding, n_neigh)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/get_highest_prune_param_embedding.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the highest pruning parameter for the SNN graph given Embedding — get_highest_prune_param_embedding","text":"embedding matrix associated PCA embedding. Embeddings dimensionality reduction techniques (LSI) can used. n_neigh number nearest neighbours.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/get_highest_prune_param_embedding.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the highest pruning parameter for the SNN graph given Embedding — get_highest_prune_param_embedding","text":"value highest pruning parameter.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/get_highest_prune_param_embedding.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Calculate the highest pruning parameter for the SNN graph given Embedding — get_highest_prune_param_embedding","text":"Given way SNN graph built, possible values pruning parameter limited can determined formula / (2 * n_neigh - ), number nearest neighbours 0 n_neigh.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/get_highest_prune_param_embedding.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the highest pruning parameter for the SNN graph given Embedding — get_highest_prune_param_embedding","text":"","code":"set.seed(2024) # create an artificial pca embedding pca_embedding <- matrix(     c(runif(100 * 10), runif(100 * 10, min = 3, max = 4)),     nrow = 200, byrow = TRUE ) rownames(pca_embedding) <- as.character(1:200) colnames(pca_embedding) <- paste(\"PC\", 1:10)  get_highest_prune_param_embedding(pca_embedding, 5) #> [1] 0"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/get_nn_conn_comps.html","id":null,"dir":"Reference","previous_headings":"","what":"Relationship Between Nearest Neighbours and Connected Components — get_nn_conn_comps","title":"Relationship Between Nearest Neighbours and Connected Components — get_nn_conn_comps","text":"One steps clustering pipeline building k-nearest neighbour graph reduced-space embedding. method assesses relationship different number nearest neighbours connectivity graph. context graph clustering, number connected components can used lower bound number clusters. calculations performed multiple times changing seed repetition.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/get_nn_conn_comps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Relationship Between Nearest Neighbours and Connected Components — get_nn_conn_comps","text":"","code":"get_nn_conn_comps(   embedding,   n_neigh_sequence,   n_repetitions = 100,   seed_sequence = NULL,   include_umap = FALSE,   umap_arguments = list() )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/get_nn_conn_comps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Relationship Between Nearest Neighbours and Connected Components — get_nn_conn_comps","text":"embedding matrix associated PCA embedding. Embeddings dimensionality reduction techniques (LSI) can used. n_neigh_sequence sequence number nearest neighbours. n_repetitions number repetitions applying pipeline different seeds; ignored seed_sequence provided user. Defaults `100“. seed_sequence custom seed sequence; value NULL, sequence built starting 1 step 100. include_umap boolean value indicating whether calculate number connected components UMAP embedding. Defaults FALSE. umap_arguments Additional arguments passed uwot::umap method.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/get_nn_conn_comps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Relationship Between Nearest Neighbours and Connected Components — get_nn_conn_comps","text":"list one field associated number nearest neighbours. value contains array number connected components obtained specified number repetitions.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/get_nn_conn_comps.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Relationship Between Nearest Neighbours and Connected Components — get_nn_conn_comps","text":"","code":"set.seed(2024) # create an artificial PCA embedding pca_emb <- matrix(runif(100 * 30), nrow = 100, byrow = TRUE) rownames(pca_emb) <- as.character(1:100) colnames(pca_emb) <- paste0(\"PCA_\", 1:30)  nn_conn_comps_obj <- get_nn_conn_comps(     embedding = pca_emb,     n_neigh_sequence = c(2, 5),     n_repetitions = 3,     # arguments that are passed to the uwot function     umap_arguments = list(         min_dist = 0.3,         metric = \"cosine\"     ) ) plot_connected_comps_evolution(nn_conn_comps_obj) #> Warning: log-10 transformation introduced infinite values."},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/length-Clustering-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Length of an Object — length,Clustering-method","title":"Length of an Object — length,Clustering-method","text":"Get number elements Clustering.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/length-Clustering-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Length of an Object — length,Clustering-method","text":"","code":"# S4 method for class 'Clustering' length(x)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/length-Clustering-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Length of an Object — length,Clustering-method","text":"x Clustering object.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/length-Clustering-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Length of an Object — length,Clustering-method","text":"number elements.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/marker_overlap.html","id":null,"dir":"Reference","previous_headings":"","what":"Cell-Wise Marker Gene Overlap — marker_overlap","title":"Cell-Wise Marker Gene Overlap — marker_overlap","text":"Calculates per-cell overlap previously calculated marker genes.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/marker_overlap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cell-Wise Marker Gene Overlap — marker_overlap","text":"","code":"marker_overlap(   markers1,   markers2,   clustering1,   clustering2,   n = 25,   overlap_type = \"jsi\",   rank_by = \"-p_val\",   use_sign = TRUE )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/marker_overlap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cell-Wise Marker Gene Overlap — marker_overlap","text":"markers1 first data frame marker genes, must contain columns called 'gene' 'cluster'. markers2 second data frame marker genes, must contain columns called 'gene' 'cluster'. clustering1 first vector cluster assignments. clustering2 second vector cluster assignments. n number top n markers (ranked rank_by) use calculating overlap. overlap_type type overlap calculated: must one 'jsi' Jaccard similarity index 'intersect' intersect size. rank_by character string giving name column rank marker genes . Note sign : rank lowest p-value, preface column name minus sign; rank highest value, higher value indicates discriminative genes (example power ROC test), sign needed. use_sign logical: sign markers match overlap calculations? gene must positive negative marker clusters compared. TRUE, markers1 markers2 must 'avg_logFC' 'avg_log2FC' column, sign DE extracted.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/marker_overlap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cell-Wise Marker Gene Overlap — marker_overlap","text":"vector marker gene overlap per cell.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/marker_overlap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cell-Wise Marker Gene Overlap — marker_overlap","text":"","code":"suppressWarnings({     set.seed(1234)     library(Seurat)     data(\"pbmc_small\")      # cluster with Louvain algorithm     pbmc_small <- FindClusters(pbmc_small, resolution = 0.8, verbose = FALSE)      # cluster with k-means     pbmc.pca <- Embeddings(pbmc_small, \"pca\")     pbmc_small@meta.data$kmeans_clusters <- kmeans(pbmc.pca, centers = 3)$cluster      # compare the markers     Idents(pbmc_small) <- pbmc_small@meta.data$seurat_clusters     louvain.markers <- FindAllMarkers(pbmc_small,         logfc.threshold = 1,         test.use = \"t\",         verbose = FALSE     )      Idents(pbmc_small) <- pbmc_small@meta.data$kmeans_clusters     kmeans.markers <- FindAllMarkers(pbmc_small,         logfc.threshold = 1,         test.use = \"t\",         verbose = FALSE     )      pbmc_small@meta.data$jsi <- marker_overlap(         louvain.markers, kmeans.markers,         pbmc_small@meta.data$seurat_clusters, pbmc_small@meta.data$kmeans_clusters     )      # which cells have the same markers, regardless of clustering?     FeaturePlot(pbmc_small, \"jsi\") }) #> Loading required package: SeuratObject #> Loading required package: sp #> ‘SeuratObject’ was built with package ‘Matrix’ 1.7.0 but the current #> version is 1.7.2; it is recomended that you reinstall ‘SeuratObject’ as #> the ABI for ‘Matrix’ may have changed #>  #> Attaching package: ‘SeuratObject’ #> The following objects are masked from ‘package:base’: #>  #>     intersect, t"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/merge_partitions.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge Partitions — merge_partitions","title":"Merge Partitions — merge_partitions","text":"Merge flat disjoint clusterings whose pairwise ECS score given threshold. merging done using complete linkage approach.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/merge_partitions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge Partitions — merge_partitions","text":"","code":"merge_partitions(   partition_list,   ecs_thresh = 1,   order_logic = c(\"freq\", \"avg_agreement\", \"none\"),   return_ecs_matrix = FALSE,   check_ties = TRUE )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/merge_partitions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Merge Partitions — merge_partitions","text":"partition_list list flat disjoint membership vectors. ecs_thresh numeric: ecs threshold. order_logic Variable indicating method ordering partitions. can take three values: \"freq\": order partitions based frequencies. partition highest frequency first list (default). \"avg_agreement\": order partitions based average agreement index. average agreement index partition calculated mean ECS scores partition partitions list. partition highest agreement  first list. \"none\": perform ordering (recommended). selected, average agreement scores calculated. return_ecs_matrix logical: TRUE, function add ECS matrix return list. Defaults FALSE. check_ties logical value indicates whether check ties highest frequency partitions . TRUE, function put first position partition highest similarity partitions. Defaults FALSE.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/merge_partitions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Merge Partitions — merge_partitions","text":"list merged partitions, together associated ECC score. return_ecs_matrix set TRUE, function also return ECS matrix.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/merge_partitions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Merge Partitions — merge_partitions","text":"","code":"initial_list <- list(c(1, 1, 2), c(2, 2, 2), c(\"B\", \"B\", \"A\")) merge_partitions(initial_list, 1) #> $partitions #> $partitions[[1]] #> $partitions[[1]]$mb #> [1] 1 1 2 #>  #> $partitions[[1]]$freq #> [1] 2 #>  #> $partitions[[1]]$avg_agreement #> [1] 0.2777778 #>  #>  #> $partitions[[2]] #> $partitions[[2]]$mb #> [1] 2 2 2 #>  #> $partitions[[2]]$freq #> [1] 1 #>  #> $partitions[[2]]$avg_agreement #> [1] 0.2777778 #>  #>  #>  #> $ecc #> [1] 0.7777778 0.7777778 0.5555556 #>"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/merge_resolutions.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge Partitions from different Resolutions — merge_resolutions","title":"Merge Partitions from different Resolutions — merge_resolutions","text":"Merge partitions obtained different resolution values. partitions grouped based number clusters. identical partitions merged single partition updating frequency using merge_partitions method.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/merge_resolutions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge Partitions from different Resolutions — merge_resolutions","text":"","code":"merge_resolutions(res_obj)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/merge_resolutions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Merge Partitions from different Resolutions — merge_resolutions","text":"res_obj list associated configuration field object returned assess_clustering_importance method.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/merge_resolutions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Merge Partitions from different Resolutions — merge_resolutions","text":"list one field assigned number clusters. number cluster contain list merged partitions. avoid duplicates, merged_partitions threshold 1 applied.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/pac_convergence.html","id":null,"dir":"Reference","previous_headings":"","what":"PAC Convergence Plot — pac_convergence","title":"PAC Convergence Plot — pac_convergence","text":"Plot PAC across iterations set k assess convergence.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/pac_convergence.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PAC Convergence Plot — pac_convergence","text":"","code":"pac_convergence(pac_res, k_plot)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/pac_convergence.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"PAC Convergence Plot — pac_convergence","text":"pac_res data.frame output consensus_cluster. k_plot vector values k plot.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/pac_convergence.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"PAC Convergence Plot — pac_convergence","text":"ggplot2 object convergence plot. Convergence reached lines flatten across k_plot values. across","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/pac_convergence.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"PAC Convergence Plot — pac_convergence","text":"","code":"pac.res <- consensus_cluster(iris[, 1:4], k_max = 20) #> Calculating consensus clustering pac_convergence(pac.res, k_plot = c(3, 5, 7, 9))"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/pac_landscape.html","id":null,"dir":"Reference","previous_headings":"","what":"PAC Landscape Plot — pac_landscape","title":"PAC Landscape Plot — pac_landscape","text":"Plot final PAC values across range k find optimal number clusters.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/pac_landscape.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PAC Landscape Plot — pac_landscape","text":"","code":"pac_landscape(pac_res, n_shade = max(pac_res$iteration)/5)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/pac_landscape.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"PAC Landscape Plot — pac_landscape","text":"pac_res data.frame output consensus_cluster. n_shade PAC values across last n_shade iterations shaded illustrate stable PAC score .","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/pac_landscape.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"PAC Landscape Plot — pac_landscape","text":"ggplot2 object final PAC vs k plot. local minimum landscape indicates especially stable value k.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/pac_landscape.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"PAC Landscape Plot — pac_landscape","text":"","code":"pac.res <- consensus_cluster(iris[, 1:4], k_max = 20) #> Calculating consensus clustering pac_landscape(pac.res)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_clustering_difference_facet.html","id":null,"dir":"Reference","previous_headings":"","what":"Clustering Method Stability Facet Plot — plot_clustering_difference_facet","title":"Clustering Method Stability Facet Plot — plot_clustering_difference_facet","text":"Display distribution EC consistency clustering method resolution value given embedding field object returned get_clustering_difference_object method used.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_clustering_difference_facet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clustering Method Stability Facet Plot — plot_clustering_difference_facet","text":"","code":"plot_clustering_difference_facet(   clust_object,   embedding,   low_limit = 0,   high_limit = 1,   grid = TRUE )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_clustering_difference_facet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clustering Method Stability Facet Plot — plot_clustering_difference_facet","text":"clust_object object returned assess_clustering_stability method. embedding embedding (first two dimensions used visualization). low_limit lowest value ECC displayed embedding. high_limit highest value ECC displayed embedding. grid Boolean value indicating whether facet grid (row associated resolution value column clustering method) wrap.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_clustering_difference_facet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Clustering Method Stability Facet Plot — plot_clustering_difference_facet","text":"ggplot2 object. #TODO export","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_clustering_difference_facet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Clustering Method Stability Facet Plot — plot_clustering_difference_facet","text":"","code":"# FIXME fix the examples # set.seed(2021) # # create an artificial PCA embedding # pca_embedding <- matrix(runif(100 * 30), nrow = 100) # rownames(pca_embedding) <- as.character(1:100) # colnames(pca_embedding) <- paste0(\"PCA_\", 1:30)  # adj_matrix <- Seurat::FindNeighbors(pca_embedding, #     k.param = 10, #     nn.method = \"rann\", #     verbose = FALSE, #     compute.SNN = FALSE # )$nn # clust_diff_obj <- assess_clustering_stability( #     graph_adjacency_matrix = adj_matrix, #     resolution = c(0.5, 1), #     n_repetitions = 10, #     algorithm = 1:2, #     verbose = FALSE # ) # plot_clustering_difference_facet(clust_diff_obj, pca_embedding)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_clustering_overall_stability.html","id":null,"dir":"Reference","previous_headings":"","what":"Clustering Method Overall Stability Boxplot — plot_clustering_overall_stability","title":"Clustering Method Overall Stability Boxplot — plot_clustering_overall_stability","text":"Display EC consistency across clustering methods summarising distribution EC consistency number clusters.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_clustering_overall_stability.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clustering Method Overall Stability Boxplot — plot_clustering_overall_stability","text":"","code":"plot_clustering_overall_stability(   clust_object,   value_type = c(\"k\", \"resolution\"),   summary_function = stats::median )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_clustering_overall_stability.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clustering Method Overall Stability Boxplot — plot_clustering_overall_stability","text":"clust_object object returned assess_clustering_stability method. value_type string specifies type value used grouping partitions calculating ECC score. can either k resolution. Defaults k. summary_function function used summarize distribution ECC values obtained number clusters. Defaults median.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_clustering_overall_stability.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Clustering Method Overall Stability Boxplot — plot_clustering_overall_stability","text":"ggplot2 object EC consistency distributions grouped clustering methods. Higher consistency indicates stable clustering.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_clustering_overall_stability.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Clustering Method Overall Stability Boxplot — plot_clustering_overall_stability","text":"","code":"set.seed(2024) # create an artificial PCA embedding pca_embedding <- matrix(runif(100 * 30), nrow = 100) rownames(pca_embedding) <- paste0(\"cell_\", seq_len(nrow(pca_embedding))) colnames(pca_embedding) <- paste0(\"PC_\", 1:30)   adj_matrix <- getNNmatrix(     RANN::nn2(pca_embedding, k = 10)$nn.idx,     10,     0,     -1 )$nn rownames(adj_matrix) <- paste0(\"cell_\", seq_len(nrow(adj_matrix))) colnames(adj_matrix) <- paste0(\"cell_\", seq_len(ncol(adj_matrix)))  # alternatively, the adj_matrix can be calculated # using the `Seurat::FindNeighbors` function.  clust_diff_obj <- assess_clustering_stability(     graph_adjacency_matrix = adj_matrix,     resolution = c(0.5, 1),     n_repetitions = 10,     clustering_algorithm = 1:2,     verbose = FALSE ) plot_clustering_overall_stability(clust_diff_obj)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_clustering_per_value_stability.html","id":null,"dir":"Reference","previous_headings":"","what":"Clustering Method per value Stability Boxplot — plot_clustering_per_value_stability","title":"Clustering Method per value Stability Boxplot — plot_clustering_per_value_stability","text":"Display EC consistency across clustering methods, calculated value resolution parameter number clusters.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_clustering_per_value_stability.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clustering Method per value Stability Boxplot — plot_clustering_per_value_stability","text":"","code":"plot_clustering_per_value_stability(   clust_object,   value_type = c(\"k\", \"resolution\") )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_clustering_per_value_stability.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clustering Method per value Stability Boxplot — plot_clustering_per_value_stability","text":"clust_object object returned assess_clustering_stability method. value_type string specifies type value used grouping partitions calculating ECC score. can either k resolution. Defaults k.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_clustering_per_value_stability.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Clustering Method per value Stability Boxplot — plot_clustering_per_value_stability","text":"ggplot2 object EC consistency distributions grouped clustering methods. Higher consistency indicates stable clustering. X axis decided value_type parameter.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_clustering_per_value_stability.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Clustering Method per value Stability Boxplot — plot_clustering_per_value_stability","text":"","code":"set.seed(2024) # create an artificial PCA embedding pca_embedding <- matrix(runif(100 * 30), nrow = 100) rownames(pca_embedding) <- paste0(\"cell_\", seq_len(nrow(pca_embedding))) colnames(pca_embedding) <- paste0(\"PC_\", 1:30)   adj_matrix <- getNNmatrix(     RANN::nn2(pca_embedding, k = 10)$nn.idx,     10,     0,     -1 )$nn rownames(adj_matrix) <- paste0(\"cell_\", seq_len(nrow(adj_matrix))) colnames(adj_matrix) <- paste0(\"cell_\", seq_len(ncol(adj_matrix)))  # alternatively, the adj_matrix can be calculated # using the `Seurat::FindNeighbors` function.  clust_diff_obj <- assess_clustering_stability(     graph_adjacency_matrix = adj_matrix,     resolution = c(0.5, 1),     n_repetitions = 10,     clustering_algorithm = 1:2,     verbose = FALSE ) plot_clustering_per_value_stability(clust_diff_obj)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_connected_comps_evolution.html","id":null,"dir":"Reference","previous_headings":"","what":"Relationship Between Number of Nearest Neighbours and Graph Connectivity — plot_connected_comps_evolution","title":"Relationship Between Number of Nearest Neighbours and Graph Connectivity — plot_connected_comps_evolution","text":"Display distribution number connected components obtained number neighbours across random seeds.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_connected_comps_evolution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Relationship Between Number of Nearest Neighbours and Graph Connectivity — plot_connected_comps_evolution","text":"","code":"plot_connected_comps_evolution(nn_conn_comps_object)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_connected_comps_evolution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Relationship Between Number of Nearest Neighbours and Graph Connectivity — plot_connected_comps_evolution","text":"nn_conn_comps_object object concatenation objects returned get_nn_conn_comps method.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_connected_comps_evolution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Relationship Between Number of Nearest Neighbours and Graph Connectivity — plot_connected_comps_evolution","text":"ggplot2 object boxplots connected component distributions.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_connected_comps_evolution.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Relationship Between Number of Nearest Neighbours and Graph Connectivity — plot_connected_comps_evolution","text":"number connected components displayed logarithmic scale.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_connected_comps_evolution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Relationship Between Number of Nearest Neighbours and Graph Connectivity — plot_connected_comps_evolution","text":"","code":"set.seed(2024) # create an artificial PCA embedding pca_emb <- matrix(runif(100 * 30), nrow = 100, byrow = TRUE) rownames(pca_emb) <- as.character(1:100) colnames(pca_emb) <- paste0(\"PCA_\", 1:30)  nn_conn_comps_obj <- get_nn_conn_comps(     embedding = pca_emb,     n_neigh_sequence = c(2, 5),     n_repetitions = 3,     # arguments that are passed to the uwot function     umap_arguments = list(         min_dist = 0.3,         metric = \"cosine\"     ) ) plot_connected_comps_evolution(nn_conn_comps_obj) #> Warning: log-10 transformation introduced infinite values."},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_feature_overall_stability_boxplot.html","id":null,"dir":"Reference","previous_headings":"","what":"Overall Feature Stability Boxplot — plot_feature_overall_stability_boxplot","title":"Overall Feature Stability Boxplot — plot_feature_overall_stability_boxplot","text":"Display EC consistency feature set step. boxplot number representing step (size subset). ECC values extracted resolution value summarized using summary_function parameter.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_feature_overall_stability_boxplot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Overall Feature Stability Boxplot — plot_feature_overall_stability_boxplot","text":"","code":"plot_feature_overall_stability_boxplot(   feature_object_list,   summary_function = stats::median,   text_size = 4,   boxplot_width = 0.4,   dodge_width = 0.7,   return_df = FALSE )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_feature_overall_stability_boxplot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Overall Feature Stability Boxplot — plot_feature_overall_stability_boxplot","text":"feature_object_list object concatenation objects returned assess_feature_stability method summary_function function used summarize ECC values. Defaults median. text_size size labels boxplots boxplot_width Used adjusting width boxplots; value passed width argument ggplot2::geom_boxplot method. dodge_width Used adjusting horizontal position boxplot; value passed width argument ggplot2::position_dodge method. return_df TRUE, function return ECS values dataframe. Default FALSE.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_feature_overall_stability_boxplot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Overall Feature Stability Boxplot — plot_feature_overall_stability_boxplot","text":"ggplot2 object.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_feature_overall_stability_boxplot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Overall Feature Stability Boxplot — plot_feature_overall_stability_boxplot","text":"","code":"set.seed(2024) # create an artificial expression matrix expr_matrix <- matrix(     c(runif(100 * 10), runif(100 * 10, min = 3, max = 4)),     nrow = 200, byrow = TRUE ) rownames(expr_matrix) <- as.character(1:200) colnames(expr_matrix) <- paste(\"feature\", 1:10)  feature_stability_result <- assess_feature_stability(     data_matrix = t(expr_matrix),     feature_set = colnames(expr_matrix),     steps = 5,     feature_type = \"feature_name\",     resolution = c(0.1, 0.5, 1),     n_repetitions = 10,     umap_arguments = list(         # the following parameters are used by the umap function         # and are not mandatory         n_neighbors = 3,         approx_pow = TRUE,         n_epochs = 0,         init = \"random\",         min_dist = 0.3     ),     clustering_algorithm = 1 ) plot_feature_overall_stability_boxplot(feature_stability_result)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_feature_overall_stability_incremental.html","id":null,"dir":"Reference","previous_headings":"","what":"Overall Feature Stability Incremental Boxplot — plot_feature_overall_stability_incremental","title":"Overall Feature Stability Incremental Boxplot — plot_feature_overall_stability_incremental","text":"Perform incremental ECS two consecutive feature steps. ECS values extracted every resolution value summarized using function (e.g. median, mean, etc.).","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_feature_overall_stability_incremental.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Overall Feature Stability Incremental Boxplot — plot_feature_overall_stability_incremental","text":"","code":"plot_feature_overall_stability_incremental(   feature_object_list,   summary_function = stats::median,   dodge_width = 0.7,   text_size = 4,   boxplot_width = 0.4,   return_df = FALSE )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_feature_overall_stability_incremental.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Overall Feature Stability Incremental Boxplot — plot_feature_overall_stability_incremental","text":"feature_object_list object concatenation objects returned assess_feature_stability method. summary_function function used summarize ECS values. Default median. dodge_width Used adjusting horizontal position boxplot; value passed width argument ggplot2::position_dodge method. text_size size labels boxplots. boxplot_width Used adjusting width boxplots; value passed width argument ggplot2::geom_boxplot method. return_df TRUE, function return ECS values dataframe. Default FALSE.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_feature_overall_stability_incremental.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Overall Feature Stability Incremental Boxplot — plot_feature_overall_stability_incremental","text":"ggplot2 object ECS distribution displayed boxplot. boxplot pair numbers representing two steps compared.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_feature_overall_stability_incremental.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Overall Feature Stability Incremental Boxplot — plot_feature_overall_stability_incremental","text":"","code":"set.seed(2024) # create an artificial expression matrix expr_matrix <- matrix(     c(runif(50 * 10), runif(50 * 10, min = 3, max = 4)),     nrow = 100, byrow = TRUE ) rownames(expr_matrix) <- as.character(1:100) colnames(expr_matrix) <- paste(\"feature\", 1:10)  feature_stability_result <- assess_feature_stability(     data_matrix = t(expr_matrix),     feature_set = colnames(expr_matrix),     steps = c(5, 10),     feature_type = \"feature_name\",     resolution = c(0.1, 0.5),     n_repetitions = 3,     umap_arguments = list(         # the following parameters are used by the umap function         # and are not mandatory         n_neighbors = 3,         approx_pow = TRUE,         n_epochs = 0,         init = \"random\",         min_dist = 0.3     ),     clustering_algorithm = 1 ) plot_feature_overall_stability_incremental(feature_stability_result)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_feature_per_resolution_stability_boxplot.html","id":null,"dir":"Reference","previous_headings":"","what":"Per resolution Feature Stability Boxplot — plot_feature_per_resolution_stability_boxplot","title":"Per resolution Feature Stability Boxplot — plot_feature_per_resolution_stability_boxplot","text":"Display EC consistency feature set step. boxplot number representing step (size subset). ECC values extracted depdening resolution value provided user.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_feature_per_resolution_stability_boxplot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Per resolution Feature Stability Boxplot — plot_feature_per_resolution_stability_boxplot","text":"","code":"plot_feature_per_resolution_stability_boxplot(   feature_object_list,   resolution,   violin_plot = FALSE,   text_size = 4,   boxplot_width = 0.4,   dodge_width = 0.7,   return_df = FALSE )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_feature_per_resolution_stability_boxplot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Per resolution Feature Stability Boxplot — plot_feature_per_resolution_stability_boxplot","text":"feature_object_list object concatenation objects returned assess_feature_stability method resolution resolution value ECC extracted. violin_plot TRUE, function return violin plot instead boxplot. Default FALSE. text_size size labels boxplots boxplot_width Used adjusting width boxplots; value passed width argument ggplot2::geom_boxplot method. dodge_width Used adjusting horizontal position boxplot; value passed width argument ggplot2::position_dodge method. return_df TRUE, function return ECS values dataframe. Default FALSE.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_feature_per_resolution_stability_boxplot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Per resolution Feature Stability Boxplot — plot_feature_per_resolution_stability_boxplot","text":"ggplot2 object.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_feature_per_resolution_stability_boxplot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Per resolution Feature Stability Boxplot — plot_feature_per_resolution_stability_boxplot","text":"","code":"set.seed(2024) # create an artificial expression matrix expr_matrix <- matrix(     c(runif(100 * 10), runif(100 * 10, min = 3, max = 4)),     nrow = 200, byrow = TRUE ) rownames(expr_matrix) <- as.character(1:200) colnames(expr_matrix) <- paste(\"feature\", 1:10)  feature_stability_result <- assess_feature_stability(     data_matrix = t(expr_matrix),     feature_set = colnames(expr_matrix),     steps = 5,     feature_type = \"feature_name\",     resolution = c(0.1, 0.5, 1),     n_repetitions = 10,     umap_arguments = list(         # the following parameters are used by the umap function         # and are not mandatory         n_neighbors = 3,         approx_pow = TRUE,         n_epochs = 0,         init = \"random\",         min_dist = 0.3     ),     clustering_algorithm = 1 ) plot_feature_per_resolution_stability_boxplot(feature_stability_result, 0.5)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_feature_per_resolution_stability_incremental.html","id":null,"dir":"Reference","previous_headings":"","what":"Per resolution - Feature Stability Incremental Boxplot — plot_feature_per_resolution_stability_incremental","title":"Per resolution - Feature Stability Incremental Boxplot — plot_feature_per_resolution_stability_incremental","text":"Perform incremental ECS two consecutive feature steps. ECS values extracted specified resolution value.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_feature_per_resolution_stability_incremental.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Per resolution - Feature Stability Incremental Boxplot — plot_feature_per_resolution_stability_incremental","text":"","code":"plot_feature_per_resolution_stability_incremental(   feature_object_list,   resolution,   dodge_width = 0.7,   text_size = 4,   boxplot_width = 0.4,   return_df = FALSE )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_feature_per_resolution_stability_incremental.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Per resolution - Feature Stability Incremental Boxplot — plot_feature_per_resolution_stability_incremental","text":"feature_object_list object concatenation objects returned assess_feature_stability method. resolution resolution value ECS extracted. dodge_width Used adjusting horizontal position boxplot; value passed width argument ggplot2::position_dodge method. text_size size labels boxplots. boxplot_width Used adjusting width boxplots; value passed width argument ggplot2::geom_boxplot method. return_df TRUE, function return ECS values dataframe. Default FALSE.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_feature_per_resolution_stability_incremental.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Per resolution - Feature Stability Incremental Boxplot — plot_feature_per_resolution_stability_incremental","text":"ggplot2 object ECS distribution displayed boxplot. boxplot pair numbers representing two steps compared.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_feature_per_resolution_stability_incremental.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Per resolution - Feature Stability Incremental Boxplot — plot_feature_per_resolution_stability_incremental","text":"","code":"set.seed(2024) # create an artificial expression matrix expr_matrix <- matrix(     c(runif(50 * 10), runif(50 * 10, min = 3, max = 4)),     nrow = 100, byrow = TRUE ) rownames(expr_matrix) <- as.character(1:100) colnames(expr_matrix) <- paste(\"feature\", 1:10)  feature_stability_result <- assess_feature_stability(     data_matrix = t(expr_matrix),     feature_set = colnames(expr_matrix),     steps = c(5, 10),     feature_type = \"feature_name\",     resolution = c(0.1, 0.5),     n_repetitions = 3,     umap_arguments = list(         # the following parameters are used by the umap function         # and are not mandatory         n_neighbors = 3,         approx_pow = TRUE,         n_epochs = 0,         init = \"random\",         min_dist = 0.3     ),     clustering_algorithm = 1 ) plot_feature_per_resolution_stability_incremental(feature_stability_result, 0.1)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_feature_stability_ecs_facet.html","id":null,"dir":"Reference","previous_headings":"","what":"Feature Stability - EC Consistency Facet Plot — plot_feature_stability_ecs_facet","title":"Feature Stability - EC Consistency Facet Plot — plot_feature_stability_ecs_facet","text":"Display facet plots subpanel associated feature set illustrates distribution EC consistency score UMAP embedding.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_feature_stability_ecs_facet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Feature Stability - EC Consistency Facet Plot — plot_feature_stability_ecs_facet","text":"","code":"plot_feature_stability_ecs_facet(   feature_object_list,   resolution,   n_facet_cols = 3,   point_size = 0.3 )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_feature_stability_ecs_facet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Feature Stability - EC Consistency Facet Plot — plot_feature_stability_ecs_facet","text":"feature_object_list object concatenation objects returned assess_feature_stability method resolution resolution value ECS extracted. n_facet_cols number facet's columns. point_size size points displayed plot.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_feature_stability_ecs_facet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Feature Stability - EC Consistency Facet Plot — plot_feature_stability_ecs_facet","text":"ggplot2 object","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_feature_stability_ecs_facet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Feature Stability - EC Consistency Facet Plot — plot_feature_stability_ecs_facet","text":"","code":"set.seed(2024) # create an artificial expression matrix expr_matrix <- matrix(     c(runif(100 * 10), runif(50 * 10, min = 3, max = 4)),     nrow = 150, byrow = TRUE ) rownames(expr_matrix) <- as.character(1:150) colnames(expr_matrix) <- paste(\"feature\", 1:10)  feature_stability_result <- assess_feature_stability(     data_matrix = t(expr_matrix),     feature_set = colnames(expr_matrix),     steps = 5,     feature_type = \"feature_name\",     resolution = c(0.1, 0.5, 1),     n_repetitions = 10,     clustering_algorithm = 1 ) plot_feature_stability_ecs_facet(     feature_stability_result,     0.5,     point_size = 2 )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_feature_stability_mb_facet.html","id":null,"dir":"Reference","previous_headings":"","what":"Feature Stability - Cluster Membership Facet Plot — plot_feature_stability_mb_facet","title":"Feature Stability - Cluster Membership Facet Plot — plot_feature_stability_mb_facet","text":"Display facet plots subpanel associated feature set illustrates distribution frequent partition UMAP embedding.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_feature_stability_mb_facet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Feature Stability - Cluster Membership Facet Plot — plot_feature_stability_mb_facet","text":"","code":"plot_feature_stability_mb_facet(   feature_object_list,   resolution,   text_size = 5,   n_facet_cols = 3,   point_size = 0.3 )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_feature_stability_mb_facet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Feature Stability - Cluster Membership Facet Plot — plot_feature_stability_mb_facet","text":"feature_object_list object concatenation objects returned assess_feature_stability method resolution resolution value ECS extracted. text_size size cluster label n_facet_cols number facet's columns. point_size size points displayed plot.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_feature_stability_mb_facet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Feature Stability - Cluster Membership Facet Plot — plot_feature_stability_mb_facet","text":"ggplot2 object.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_feature_stability_mb_facet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Feature Stability - Cluster Membership Facet Plot — plot_feature_stability_mb_facet","text":"","code":"set.seed(2024) # create an artificial expression matrix expr_matrix <- matrix(     c(runif(100 * 10), runif(50 * 10, min = 3, max = 4)),     nrow = 150, byrow = TRUE ) rownames(expr_matrix) <- as.character(1:150) colnames(expr_matrix) <- paste(\"feature\", 1:10)  feature_stability_result <- assess_feature_stability(     data_matrix = t(expr_matrix),     feature_set = colnames(expr_matrix),     steps = 5,     feature_type = \"feature_name\",     resolution = c(0.1, 0.5, 1),     n_repetitions = 10,     clustering_algorithm = 1 ) plot_feature_stability_mb_facet(     feature_stability_result,     0.5,     point_size = 2 )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_k_n_partitions.html","id":null,"dir":"Reference","previous_headings":"","what":"Relationship Between the Number of Clusters and the Number of Unique Partitions — plot_k_n_partitions","title":"Relationship Between the Number of Clusters and the Number of Unique Partitions — plot_k_n_partitions","text":"configuration provided clust_object, display many different partitions number clusters can obtained changing seed.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_k_n_partitions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Relationship Between the Number of Clusters and the Number of Unique Partitions — plot_k_n_partitions","text":"","code":"plot_k_n_partitions(   clust_object,   colour_information = c(\"ecc\", \"freq_part\"),   dodge_width = 0.3,   pt_size_range = c(1.5, 4),   summary_function = stats::median,   y_step = 5 )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_k_n_partitions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Relationship Between the Number of Clusters and the Number of Unique Partitions — plot_k_n_partitions","text":"clust_object object returned assess_clustering_stability method. colour_information String specifies information type illustrated using gradient colour: either freq_part frequency common partition ecc Element-Centric Consistency partitions obtained number clusters fixed. Defaults ecc. dodge_width Used adjusting distance boxplots representing clustering method. Defaults 0.3. pt_size_range Indicates minimum maximum size point plot can . Defaults c(1.5, 4). summary_function function used summarize distribution ECC values obtained number clusters. Defaults median. y_step step used y-axis. Defaults 5.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_k_n_partitions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Relationship Between the Number of Clusters and the Number of Unique Partitions — plot_k_n_partitions","text":"ggplot2 object. color gradient suggests frequency common partition relative total number appearances specific number clusters Element-Centric Consistency partitions. size illustrates frequency partitions k clusters relative total number partitions. shape points indicates clustering method.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_k_n_partitions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Relationship Between the Number of Clusters and the Number of Unique Partitions — plot_k_n_partitions","text":"","code":"set.seed(2024) # create an artificial PCA embedding pca_embedding <- matrix(runif(100 * 30), nrow = 100) rownames(pca_embedding) <- paste0(\"cell_\", seq_len(nrow(pca_embedding))) colnames(pca_embedding) <- paste0(\"PC_\", 1:30)   adj_matrix <- getNNmatrix(     RANN::nn2(pca_embedding, k = 10)$nn.idx,     10,     0,     -1 )$nn rownames(adj_matrix) <- paste0(\"cell_\", seq_len(nrow(adj_matrix))) colnames(adj_matrix) <- paste0(\"cell_\", seq_len(ncol(adj_matrix)))  # alternatively, the adj_matrix can be calculated # using the `Seurat::FindNeighbors` function.  clust_diff_obj <- assess_clustering_stability(     graph_adjacency_matrix = adj_matrix,     resolution = c(0.5, 1),     n_repetitions = 10,     clustering_algorithm = 1:2,     verbose = FALSE ) plot_k_n_partitions(clust_diff_obj)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_k_resolution_corresp.html","id":null,"dir":"Reference","previous_headings":"","what":"Correspondence Between Resolution and the Number of Clusters — plot_k_resolution_corresp","title":"Correspondence Between Resolution and the Number of Clusters — plot_k_resolution_corresp","text":"configuration provided clust_object, display number clusters appear different values resolution parameters.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_k_resolution_corresp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Correspondence Between Resolution and the Number of Clusters — plot_k_resolution_corresp","text":"","code":"plot_k_resolution_corresp(   clust_object,   colour_information = c(\"ecc\", \"freq_k\"),   dodge_width = 0.3,   pt_size_range = c(1.5, 4),   summary_function = stats::median )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_k_resolution_corresp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Correspondence Between Resolution and the Number of Clusters — plot_k_resolution_corresp","text":"clust_object object returned assess_clustering_stability method. colour_information String specifies information type illustrated using gradient colour: either freq_part frequency common partition ecc Element-Centric Consistency partitions obtained number clusters fixed. Defaults ecc. dodge_width Used adjusting distance boxplots representing clustering method. Defaults 0.3. pt_size_range Indicates minimum maximum size point plot can . Defaults c(1.5, 4). summary_function function used summarize distribution ECC values obtained number clusters. Defaults median.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_k_resolution_corresp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Correspondence Between Resolution and the Number of Clusters — plot_k_resolution_corresp","text":"ggplot2 object. Different shapes points indicate different parameter configuration, color illustrates frequency common partition Element-Centric Consistency partitions. frequency calculated fraction number total appearances partitions specific number clusters resolution value number runs. size illustrates frequency common partition k clusters relative partitions obtained resolution value k clusters.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_k_resolution_corresp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Correspondence Between Resolution and the Number of Clusters — plot_k_resolution_corresp","text":"","code":"set.seed(2024) # create an artificial PCA embedding pca_embedding <- matrix(runif(100 * 30), nrow = 100) rownames(pca_embedding) <- paste0(\"cell_\", seq_len(nrow(pca_embedding))) colnames(pca_embedding) <- paste0(\"PC_\", 1:30)   adj_matrix <- getNNmatrix(     RANN::nn2(pca_embedding, k = 10)$nn.idx,     10,     0,     -1 )$nn rownames(adj_matrix) <- paste0(\"cell_\", seq_len(nrow(adj_matrix))) colnames(adj_matrix) <- paste0(\"cell_\", seq_len(ncol(adj_matrix)))  # alternatively, the adj_matrix can be calculated # using the `Seurat::FindNeighbors` function.  clust_diff_obj <- assess_clustering_stability(     graph_adjacency_matrix = adj_matrix,     resolution = c(0.5, 1),     n_repetitions = 10,     clustering_algorithm = 1:2,     verbose = FALSE ) plot_k_resolution_corresp(clust_diff_obj)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_n_neigh_ecs.html","id":null,"dir":"Reference","previous_headings":"","what":"Graph construction parameters - ECC facet — plot_n_neigh_ecs","title":"Graph construction parameters - ECC facet — plot_n_neigh_ecs","text":"Display, configurations consisting different number neighbours, graph types base embeddings, EC Consistency partitions obtained multiple runs UMAP embedding.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_n_neigh_ecs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Graph construction parameters - ECC facet — plot_n_neigh_ecs","text":"","code":"plot_n_neigh_ecs(nn_ecs_object, boxplot_width = 0.5)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_n_neigh_ecs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Graph construction parameters - ECC facet — plot_n_neigh_ecs","text":"nn_ecs_object object concatenation objects returned get_nn_importance method. boxplot_width Used adjusting width boxplots; value passed width argument ggplot2::geom_boxplot method.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_n_neigh_ecs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Graph construction parameters - ECC facet — plot_n_neigh_ecs","text":"ggplot2 object.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_n_neigh_ecs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Graph construction parameters - ECC facet — plot_n_neigh_ecs","text":"","code":"set.seed(2024) # create an artificial PCA embedding pca_emb <- matrix(runif(100 * 30), nrow = 100, byrow = TRUE) rownames(pca_emb) <- as.character(1:100) colnames(pca_emb) <- paste0(\"PC_\", 1:30)  nn_stability_obj <- assess_nn_stability(     embedding = pca_emb,     n_neigh_sequence = c(10, 15, 20),     n_repetitions = 10,     graph_reduction_type = \"PCA\",     clustering_algorithm = 1 ) plot_n_neigh_ecs(nn_stability_obj)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_n_neigh_k_correspondence.html","id":null,"dir":"Reference","previous_headings":"","what":"Relationship Between Number of Nearest Neighbours and Number of Clusters — plot_n_neigh_k_correspondence","title":"Relationship Between Number of Nearest Neighbours and Number of Clusters — plot_n_neigh_k_correspondence","text":"Display distribution number clusters obtained number neighbours across random seeds.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_n_neigh_k_correspondence.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Relationship Between Number of Nearest Neighbours and Number of Clusters — plot_n_neigh_k_correspondence","text":"","code":"plot_n_neigh_k_correspondence(nn_object_n_clusters)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_n_neigh_k_correspondence.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Relationship Between Number of Nearest Neighbours and Number of Clusters — plot_n_neigh_k_correspondence","text":"nn_object_n_clusters object concatenation objects returned get_nn_importance method.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_n_neigh_k_correspondence.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Relationship Between Number of Nearest Neighbours and Number of Clusters — plot_n_neigh_k_correspondence","text":"ggplot2 object distributions displayed boxplots.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_n_neigh_k_correspondence.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Relationship Between Number of Nearest Neighbours and Number of Clusters — plot_n_neigh_k_correspondence","text":"number clusters displayed logarithmic scale.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/plot_n_neigh_k_correspondence.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Relationship Between Number of Nearest Neighbours and Number of Clusters — plot_n_neigh_k_correspondence","text":"","code":"set.seed(2024) # create an artificial PCA embedding pca_emb <- matrix(runif(100 * 30), nrow = 100, byrow = TRUE) rownames(pca_emb) <- as.character(1:100) colnames(pca_emb) <- paste0(\"PC_\", 1:30)  nn_stability_obj <- assess_nn_stability(     embedding = pca_emb,     n_neigh_sequence = c(10, 15, 20),     n_repetitions = 10,     graph_reduction_type = \"PCA\",     clustering_algorithm = 1 ) plot_n_neigh_k_correspondence(nn_stability_obj) #> Warning: log-10 transformation introduced infinite values."},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/print-Clustering-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Print an Object — print,Clustering-method","title":"Print an Object — print,Clustering-method","text":"Prints information Clustering, including number elements.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/print-Clustering-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print an Object — print,Clustering-method","text":"","code":"# S4 method for class 'Clustering' print(x)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/print-Clustering-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print an Object — print,Clustering-method","text":"x Clustering object.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/print-Clustering-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print an Object — print,Clustering-method","text":"printed character string.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/server_comparisons.html","id":null,"dir":"Reference","previous_headings":"","what":"Server - Comparison module — server_comparisons","title":"Server - Comparison module — server_comparisons","text":"Creates backend interface comparison module inside ClustAssess Shiny application.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/server_comparisons.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Server - Comparison module — server_comparisons","text":"","code":"server_comparisons(id, chosen_config, chosen_method)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/server_comparisons.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Server - Comparison module — server_comparisons","text":"id id module, used acess UI elements. chosen_config reactive object contains chosen configuration Dimensionality Reduction tab. chosen_method reactive object contains chosen method Clustering tab.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/server_comparisons.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Server - Comparison module — server_comparisons","text":"function called directly, context app created using write_shiny_app function.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/server_dimensionality_reduction.html","id":null,"dir":"Reference","previous_headings":"","what":"Server - Dimensionality reduction module — server_dimensionality_reduction","title":"Server - Dimensionality reduction module — server_dimensionality_reduction","text":"Creates backend interface dimensionality reduction module inside ClustAssess Shiny application.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/server_dimensionality_reduction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Server - Dimensionality reduction module — server_dimensionality_reduction","text":"","code":"server_dimensionality_reduction(id, parent_session)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/server_dimensionality_reduction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Server - Dimensionality reduction module — server_dimensionality_reduction","text":"id id module, used acess UI elements. parent_session session parent module, used control tabs application.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/server_dimensionality_reduction.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Server - Dimensionality reduction module — server_dimensionality_reduction","text":"function called directly, context app created using write_shiny_app function.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/server_graph_clustering.html","id":null,"dir":"Reference","previous_headings":"","what":"Server - Graph clustering module — server_graph_clustering","title":"Server - Graph clustering module — server_graph_clustering","text":"Creates backend interface graph clustering module inside ClustAssess Shiny application.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/server_graph_clustering.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Server - Graph clustering module — server_graph_clustering","text":"","code":"server_graph_clustering(id, feature_choice, parent_session)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/server_graph_clustering.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Server - Graph clustering module — server_graph_clustering","text":"id id module, used acess UI elements. feature_choice reactive object contains chosen configuration Dimensionality Reduction tab. parent_session session parent module, used control tabs application.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/server_graph_clustering.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Server - Graph clustering module — server_graph_clustering","text":"function called directly, context app created using write_shiny_app function.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/server_graph_construction.html","id":null,"dir":"Reference","previous_headings":"","what":"Server - Graph construction module — server_graph_construction","title":"Server - Graph construction module — server_graph_construction","text":"Creates backend interface graph construction module inside ClustAssess Shiny application.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/server_graph_construction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Server - Graph construction module — server_graph_construction","text":"","code":"server_graph_construction(id, chosen_config)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/server_graph_construction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Server - Graph construction module — server_graph_construction","text":"id id module, used acess UI elements. chosen_config reactive object contains chosen configuration Dimensionality Reduction tab.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/server_graph_construction.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Server - Graph construction module — server_graph_construction","text":"function called directly, context app created using write_shiny_app function.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/server_landing_page.html","id":null,"dir":"Reference","previous_headings":"","what":"Server - Landing page module — server_landing_page","title":"Server - Landing page module — server_landing_page","text":"Creates backend interface landing page module inside ClustAssess Shiny application.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/server_landing_page.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Server - Landing page module — server_landing_page","text":"","code":"server_landing_page(   id,   height_ratio,   dimension,   parent_session,   organism = \"hsapiens\" )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/server_landing_page.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Server - Landing page module — server_landing_page","text":"id id module, used acess UI elements. height_ratio reactive object contains height ratio plots application (height plot calculated using height ratio height webpage). dimension reactive object contains dimensions webpage. parent_session session parent module, used control tabs application. organism organism dataset, used enrichment analysis.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/server_landing_page.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Server - Landing page module — server_landing_page","text":"function called directly, context app created using write_shiny_app function.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/server_sandbox.html","id":null,"dir":"Reference","previous_headings":"","what":"Server - Sandbox module — server_sandbox","title":"Server - Sandbox module — server_sandbox","text":"Creates backend interface sandbox module inside ClustAssess Shiny application.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/server_sandbox.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Server - Sandbox module — server_sandbox","text":"","code":"server_sandbox(id)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/server_sandbox.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Server - Sandbox module — server_sandbox","text":"id id module, used acess UI elements.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/server_sandbox.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Server - Sandbox module — server_sandbox","text":"function called directly, context app created using write_shiny_app function.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/ui_comparisons.html","id":null,"dir":"Reference","previous_headings":"","what":"UI - Comparison module — ui_comparisons","title":"UI - Comparison module — ui_comparisons","text":"Creates UI interface comparison module inside ClustAssess Shiny application.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/ui_comparisons.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"UI - Comparison module — ui_comparisons","text":"","code":"ui_comparisons(id)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/ui_comparisons.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"UI - Comparison module — ui_comparisons","text":"id id module, used identify UI elements.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/ui_comparisons.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"UI - Comparison module — ui_comparisons","text":"function called directly, context app created using write_shiny_app function.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/ui_dimensionality_reduction.html","id":null,"dir":"Reference","previous_headings":"","what":"UI - Dimensionality reduction module — ui_dimensionality_reduction","title":"UI - Dimensionality reduction module — ui_dimensionality_reduction","text":"Creates UI interface dimensionality reduction module inside ClustAssess Shiny application.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/ui_dimensionality_reduction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"UI - Dimensionality reduction module — ui_dimensionality_reduction","text":"","code":"ui_dimensionality_reduction(id)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/ui_dimensionality_reduction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"UI - Dimensionality reduction module — ui_dimensionality_reduction","text":"id id module, used identify UI elements.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/ui_dimensionality_reduction.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"UI - Dimensionality reduction module — ui_dimensionality_reduction","text":"function called directly, context app created using write_shiny_app function.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/ui_graph_clustering.html","id":null,"dir":"Reference","previous_headings":"","what":"UI - Graph clustering module — ui_graph_clustering","title":"UI - Graph clustering module — ui_graph_clustering","text":"Creates UI interface graph clustering module inside ClustAssess Shiny application.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/ui_graph_clustering.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"UI - Graph clustering module — ui_graph_clustering","text":"","code":"ui_graph_clustering(id)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/ui_graph_clustering.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"UI - Graph clustering module — ui_graph_clustering","text":"id id module, used identify UI elements.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/ui_graph_clustering.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"UI - Graph clustering module — ui_graph_clustering","text":"function called directly, context app created using write_shiny_app function.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/ui_graph_construction.html","id":null,"dir":"Reference","previous_headings":"","what":"UI - Graph construction module — ui_graph_construction","title":"UI - Graph construction module — ui_graph_construction","text":"Creates UI interface graph construction module inside ClustAssess Shiny application.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/ui_graph_construction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"UI - Graph construction module — ui_graph_construction","text":"","code":"ui_graph_construction(id)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/ui_graph_construction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"UI - Graph construction module — ui_graph_construction","text":"id id module, used identify UI elements.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/ui_graph_construction.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"UI - Graph construction module — ui_graph_construction","text":"function called directly, context app created using write_shiny_app function.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/ui_landing_page.html","id":null,"dir":"Reference","previous_headings":"","what":"UI - Landing page module — ui_landing_page","title":"UI - Landing page module — ui_landing_page","text":"Creates UI interface landing page module inside ClustAssess Shiny application.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/ui_landing_page.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"UI - Landing page module — ui_landing_page","text":"","code":"ui_landing_page(id)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/ui_landing_page.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"UI - Landing page module — ui_landing_page","text":"id id module, used identify UI elements.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/ui_landing_page.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"UI - Landing page module — ui_landing_page","text":"function called directly, context app created using write_shiny_app function.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/ui_sandbox.html","id":null,"dir":"Reference","previous_headings":"","what":"UI - Sandbox module — ui_sandbox","title":"UI - Sandbox module — ui_sandbox","text":"Creates UI interface sandbox module inside ClustAssess Shiny application.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/ui_sandbox.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"UI - Sandbox module — ui_sandbox","text":"","code":"ui_sandbox(id)"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/ui_sandbox.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"UI - Sandbox module — ui_sandbox","text":"id id module, used identify UI elements.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/ui_sandbox.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"UI - Sandbox module — ui_sandbox","text":"function called directly, context app created using write_shiny_app function.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/weighted_element_consistency.html","id":null,"dir":"Reference","previous_headings":"","what":"Weighted Element-Centric Consistency — weighted_element_consistency","title":"Weighted Element-Centric Consistency — weighted_element_consistency","text":"Calculate weighted element-centric consistency set clusterings. weights used give importance clusterings others.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/weighted_element_consistency.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Weighted Element-Centric Consistency — weighted_element_consistency","text":"","code":"weighted_element_consistency(   clustering_list,   weights = NULL,   calculate_sim_matrix = FALSE )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/weighted_element_consistency.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Weighted Element-Centric Consistency — weighted_element_consistency","text":"clustering_list list clustering results, either: numeric/character/factor vector cluster labels element. samples x clusters matrix/Matrix::Matrix nonzero membership values. hclust object. weights numeric vector weights clustering clustering_list. NULL, weights equal 1. Defaults NULL. calculate_sim_matrix logical value indicates whether calculate similarity matrix along consistency score. Defaults FALSE.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/weighted_element_consistency.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Weighted Element-Centric Consistency — weighted_element_consistency","text":"vector containing weighted element-wise consistency. calculate_sim_matrix set TRUE, element similarity matrix returned well.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/weighted_element_consistency.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Weighted Element-Centric Consistency — weighted_element_consistency","text":"weighted ECC calculated \\(\\displaystyle \\frac{\\sum_{} \\sum_{j} w_i w_j ECS(, j)}{\\sum_{} w_i}\\)","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/weighted_element_consistency.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Weighted Element-Centric Consistency — weighted_element_consistency","text":"","code":"# cluster across 20 random seeds clustering_list <- lapply(1:20, function(x) kmeans(mtcars, centers = 3)$cluster) weights <- sample(1:10, 20, replace = TRUE) weighted_element_consistency(clustering_list, weights = weights) #>           Mazda RX4       Mazda RX4 Wag          Datsun 710      Hornet 4 Drive  #>           0.6750269           0.6750269           0.8437837           0.5971647  #>   Hornet Sportabout             Valiant          Duster 360           Merc 240D  #>           0.7748918           0.5612399           0.7748918           0.8437837  #>            Merc 230            Merc 280           Merc 280C          Merc 450SE  #>           0.8437837           0.6750269           0.6750269           0.6750297  #>          Merc 450SL         Merc 450SLC  Cadillac Fleetwood Lincoln Continental  #>           0.6750297           0.6750297           0.7391709           0.7391709  #>   Chrysler Imperial            Fiat 128         Honda Civic      Toyota Corolla  #>           0.7391709           0.8437837           0.8437837           0.8437837  #>       Toyota Corona    Dodge Challenger         AMC Javelin          Camaro Z28  #>           0.8437837           0.6750297           0.6750297           0.7748918  #>    Pontiac Firebird           Fiat X1-9       Porsche 914-2        Lotus Europa  #>           0.7391709           0.8437837           0.8437837           0.8437837  #>      Ford Pantera L        Ferrari Dino       Maserati Bora          Volvo 142E  #>           0.7748918           0.6750269           0.7748918           0.8437837"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/write_objects.html","id":null,"dir":"Reference","previous_headings":"","what":"Write the objects for the ClustAssess ShinyApp — write_objects","title":"Write the objects for the ClustAssess ShinyApp — write_objects","text":"Given output ClustAssess pipeline, expression matrix metadata, function creates files needed ClustAssess ShinyApp. files written project_folder following: metadata.rds: metadata file stability.h5: contains stability results expression.h5: contains expression matrix rank matrix","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/write_objects.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write the objects for the ClustAssess ShinyApp — write_objects","text":"","code":"write_objects(   clustassess_object,   expression_matrix,   metadata,   project_folder = \".\",   compression_level = 6,   chunk_size = 100,   gene_variance_threshold = 0,   summary_function = stats::median,   qualpalr_colorspace = \"pretty\" )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/write_objects.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write the objects for the ClustAssess ShinyApp — write_objects","text":"clustassess_object output ClustAssess automatic pipeline expression_matrix expression matrix metadata metadata project_folder folder files written compression_level compression level h5 files (See `rhdf5::h5createFile“ details) chunk_size chunk size rank matrix (See rhdf5::h5createDataset details) gene_variance_threshold threshold gene variance; genes variance threshold removed summary_function function used summarizing stability values; default median qualpalr_colorspace colorspace used generating colors; default pretty","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/write_objects.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Write the objects for the ClustAssess ShinyApp — write_objects","text":"NULL (files written project_folder)","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/write_shiny_app.html","id":null,"dir":"Reference","previous_headings":"","what":"Create the ClustAssess ShinyApp — write_shiny_app","title":"Create the ClustAssess ShinyApp — write_shiny_app","text":"Creates ClustAssess ShinyApp based output automatic ClustAssess pipeline. addition , expression matrix metadata dataframe provided input ShinyApp.","code":""},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/write_shiny_app.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create the ClustAssess ShinyApp — write_shiny_app","text":"","code":"write_shiny_app(   object,   metadata = NULL,   assay_name = NULL,   clustassess_object,   project_folder,   compression_level = 6,   summary_function = stats::median,   shiny_app_title = \"\",   organism_enrichment = \"hsapiens\",   height_ratio = 0.6,   qualpalr_colorspace = \"pretty\" )  # S3 method for class 'Seurat' write_shiny_app(   object,   metadata = NULL,   assay_name,   clustassess_object,   project_folder,   compression_level = 6,   summary_function = stats::median,   shiny_app_title = \"\",   organism_enrichment = \"hsapiens\",   height_ratio = 0.6,   qualpalr_colorspace = \"pretty\" )  # Default S3 method write_shiny_app(   object,   metadata = NULL,   assay_name = NULL,   clustassess_object,   project_folder,   compression_level = 6,   summary_function = stats::median,   shiny_app_title = \"\",   organism_enrichment = \"hsapiens\",   height_ratio = 0.6,   qualpalr_colorspace = \"pretty\" )"},{"path":"https://core-bioinformatics.github.io/ClustAssess/reference/write_shiny_app.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create the ClustAssess ShinyApp — write_shiny_app","text":"object Seurat object expression matrix metadata metadata dataframe. parameter ignored object Seurat object. assay_name name assay used extract expression matrix Seurat object. parameter ignored object Seurat object. clustassess_object output ClustAssess automatic pipeline project_folder folder files written compression_level compression level h5 files (See `rhdf5::h5createFile“ details) summary_function function used summarizing stability values; default median shiny_app_title title shiny app organism_enrichment organism used enrichment analysis; default hsapiens height_ratio ratio height plot height browser; default 0.6 qualpalr_colorspace colorspace used generating colors; default pretty","code":""}]
